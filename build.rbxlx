<roblox version="4">
  <Item class="Lighting" referent="0">
    <Properties>
      <string name="Name">Lighting</string>
      <Color3 name="Ambient">
        <R>0</R>
        <G>0</G>
        <B>0</B>
      </Color3>
      <float name="Brightness">2</float>
      <bool name="GlobalShadows">true</bool>
      <bool name="Outlines">false</bool>
      <token name="Technology">1</token>
    </Properties>
  </Item>
  <Item class="ReplicatedStorage" referent="1">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="2">
      <Properties>
        <string name="Name">Shared</string>
      </Properties>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">AutomationConfig</string>
          <string name="Source"><![CDATA[local AutomationConfig = {}

type AutomationDefinition = {
	id: string,
	name: string,
	description: string,
	unlockRequirement: {
		storageTier: number?,
		milestone: string?,
	},
	intervalSeconds: number,
	enabledByDefault: boolean,
}

local definitions: { AutomationDefinition } = {
	{
		id = "auto_cpu",
		name = "CPU Auto Builder",
		description = "Automatically purchases CPU upgrades when possible.",
		unlockRequirement = {
			storageTier = 1,
		},
		intervalSeconds = 2.0,
		enabledByDefault = false,
	},
	{
		id = "auto_ram",
		name = "RAM Auto Optimizer",
		description = "Automatically purchases RAM upgrades when possible.",
		unlockRequirement = {
			storageTier = 2,
		},
		intervalSeconds = 2.0,
		enabledByDefault = false,
	},
}

local byId = {}
for _, automation in ipairs(definitions) do
	byId[automation.id] = automation
end

function AutomationConfig.GetAll()
	return definitions
end

function AutomationConfig.GetById(id)
	return byId[id]
end

return AutomationConfig
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">BoostService</string>
          <string name="Source"><![CDATA[local BoostService = {}

local BOOST_DEFINITIONS = {
	["+5 Min Boost"] = {
		duration = 5 * 60,
		multiplier = 2,
		sku = "Dev_5MinBoost",
	},
	["+1 Hour Boost"] = {
		duration = 60 * 60,
		multiplier = 2,
		sku = "Dev_1HourBoost",
	},
}

function BoostService.GetDefinition(boostName)
	return BOOST_DEFINITIONS[boostName]
end

function BoostService.GetDefinitions()
	return BOOST_DEFINITIONS
end

function BoostService.GetMultiplier(boostName)
	local definition = BOOST_DEFINITIONS[boostName]
	if definition and typeof(definition.multiplier) == "number" then
		return definition.multiplier
	end
	return 1
end

return BoostService
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">EconomyAnalytics.lua</string>
          <string name="Source"></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">NumberFormatter</string>
          <string name="Source"><![CDATA[local NumberFormatter = {}

local FORMAT_STEPS = {
	{
		limit = 1_000,
		divisor = 1,
		suffix = "",
	},
	{
		limit = 1_000_000,
		divisor = 1_000,
		suffix = "K",
	},
	{
		limit = 1_000_000_000,
		divisor = 1_000_000,
		suffix = "M",
	},
	{
		limit = 1_000_000_000_000,
		divisor = 1_000_000_000,
		suffix = "B",
	},
}

local function trimTrailingZeros(text)
	local trimmed = text:gsub("%.?0+$", "")
	if trimmed == "" or trimmed == "-" then
		return "0"
	end
	return trimmed
end

local function formatWithSuffix(value, divisor, suffix)
	local scaled = value / divisor
	local formatted = string.format("%.2f", scaled)
	return trimTrailingZeros(formatted) .. suffix
end

function NumberFormatter.format(value)
	local numberValue = tonumber(value)
	if not numberValue then
		return "0"
	end

	local absValue = math.abs(numberValue)

	for _, step in FORMAT_STEPS do
		if absValue < step.limit then
			return formatWithSuffix(numberValue, step.divisor, step.suffix)
		end
	end

	return string.format("%.2e", numberValue)
end

return NumberFormatter
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="7">
        <Properties>
          <string name="Name">OfflineProgress</string>
          <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local BoostService = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("BoostService"))

local OfflineProgress = {}

local function sanitizeTimestamp(value, fallback)
	if typeof(value) == "number" then
		return value
	end
	return fallback
end

local function computeActiveBoostMultiplier(boosts, referenceTime)
	local multiplier = 1

	for boostName, expiration in pairs(boosts) do
		if typeof(expiration) == "number" and expiration > referenceTime then
			local definition = BoostService.GetDefinition(boostName)
			if definition and typeof(definition.multiplier) == "number" then
				multiplier *= definition.multiplier
			end
		end
	end

	return multiplier
end

local function collectNextExpiration(boosts, referenceTime, upperBound)
	local nextExpiration = upperBound
	local hasActive = false

	for _, expiration in pairs(boosts) do
		if typeof(expiration) == "number" and expiration > referenceTime then
			hasActive = true
			if expiration < nextExpiration then
				nextExpiration = expiration
			end
		end
	end

	if not hasActive then
		return nil
	end

	return nextExpiration
end

local function trimExpiredBoosts(boosts, now)
	for boostName, expiration in pairs(boosts) do
		if typeof(expiration) ~= "number" or expiration <= now then
			boosts[boostName] = nil
		end
	end
end

function OfflineProgress.Calculate(data, baseDps, now)
	if typeof(data) ~= "table" then
		return 0, now
	end

	local sanitizedNow = sanitizeTimestamp(now, os.time())
	local lastSeen = sanitizeTimestamp(data.lastSeen, sanitizedNow)

	if sanitizedNow <= lastSeen or typeof(baseDps) ~= "number" or baseDps <= 0 then
		data.lastSeen = sanitizedNow
		trimExpiredBoosts(data.boosts or {}, sanitizedNow)
		return 0, sanitizedNow
	end

	local boosts = data.boosts
	if typeof(boosts) ~= "table" then
		boosts = {}
		data.boosts = boosts
	end

	local totalGain = 0
	local baseGain = 0
	local boostedGain = 0
	local cursor = lastSeen
	local usedBoosts = false

	while cursor < sanitizedNow do
		local nextExpiration = collectNextExpiration(boosts, cursor, sanitizedNow)
		local segmentEnd = nextExpiration and math.min(nextExpiration, sanitizedNow) or sanitizedNow
		local duration = math.max(0, segmentEnd - cursor)
		if duration <= 0 then
			break
		end

		local multiplier = computeActiveBoostMultiplier(boosts, cursor)
		local clampedMultiplier = math.max(1, multiplier)
		local baseSegment = baseDps * duration
		local boostedSegment = baseDps * math.max(0, clampedMultiplier - 1) * duration

		if multiplier > 1 then
			usedBoosts = true
		end

		baseGain += baseSegment
		boostedGain += boostedSegment
		totalGain += baseSegment + boostedSegment

		cursor = segmentEnd
		if not nextExpiration then
			break
		end
	end

	trimExpiredBoosts(boosts, sanitizedNow)
	data.lastSeen = sanitizedNow
	return totalGain, sanitizedNow, usedBoosts, baseGain, boostedGain
end

return OfflineProgress
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="8">
        <Properties>
          <string name="Name">UpgradeConfig</string>
          <string name="Source"><![CDATA[local UpgradeConfig = {}

type UpgradeDefinition = {
	id: string,
	branch: string,
	name: string,
	description: string,
	baseCost: number,
	costScale: number,
	maxLevel: number,
	requires: {
		storageTier: number?,
		requiresUpgradeId: string?,
	}?,
	effect: (level: number) -> {
		flatDps: number,
		multiplier: number,
		storageTier: number,
	},
}

local function buildEffect(flatPerLevel, multiplierPerLevel, storageTierValue)
	return function(level: number)
		local clampedLevel = math.max(level, 0)

		local flat = flatPerLevel and (flatPerLevel * clampedLevel) or 0
		local multiplier = multiplierPerLevel and (multiplierPerLevel * clampedLevel) or 0
		local storageTier = (storageTierValue and clampedLevel >= 1) and storageTierValue or 0

		return {
			flatDps = flat,
			multiplier = multiplier,
			storageTier = storageTier,
		}
	end
end

local allUpgrades: { UpgradeDefinition } = {
	-- CPU Branch
	{
		id = "cpu_1",
		branch = "CPU",
		name = "Clock Boost",
		description = "+1 Data/sec per level.",
		baseCost = 5,
		costScale = 1.25,
		maxLevel = 50,
		effect = buildEffect(1, nil, nil),
	},
	{
		id = "cpu_2",
		branch = "CPU",
		name = "Core Threads",
		description = "+5 Data/sec per level.",
		baseCost = 150,
		costScale = 1.35,
		maxLevel = 35,
		requires = {
			storageTier = 2,
		},
		effect = buildEffect(5, nil, nil),
	},
	{
		id = "cpu_3",
		branch = "CPU",
		name = "Overclock Mode",
		description = "+20 Data/sec per level.",
		baseCost = 2_000,
		costScale = 1.45,
		maxLevel = 25,
		requires = {
			storageTier = 3,
		},
		effect = buildEffect(20, nil, nil),
	},

	-- RAM Branch
	{
		id = "ram_1",
		branch = "RAM",
		name = "Cache Boost",
		description = "+10% global per level.",
		baseCost = 50,
		costScale = 1.3,
		maxLevel = 30,
		effect = buildEffect(nil, 0.10, nil),
	},
	{
		id = "ram_2",
		branch = "RAM",
		name = "Memory Optimization",
		description = "+25% global per level.",
		baseCost = 800,
		costScale = 1.4,
		maxLevel = 20,
		requires = {
			storageTier = 2,
		},
		effect = buildEffect(nil, 0.25, nil),
	},

	-- STORAGE Branch
	{
		id = "sto_1",
		branch = "STORAGE",
		name = "Disk Partition",
		description = "Unlock Storage Tier 1.",
		baseCost = 2_500,
		costScale = 1.0,
		maxLevel = 1,
		effect = buildEffect(nil, nil, 1),
	},
	{
		id = "sto_2",
		branch = "STORAGE",
		name = "SSD Upgrade",
		description = "Unlock Storage Tier 2.",
		baseCost = 25_000,
		costScale = 1.0,
		maxLevel = 1,
		requires = {
			requiresUpgradeId = "sto_1",
		},
		effect = buildEffect(nil, nil, 2),
	},
	{
		id = "sto_3",
		branch = "STORAGE",
		name = "NVMe Array",
		description = "Unlock Storage Tier 3 (Prestige).",
		baseCost = 250_000,
		costScale = 1.0,
		maxLevel = 1,
		requires = {
			requiresUpgradeId = "sto_2",
		},
		effect = buildEffect(nil, nil, 3),
	},
}

local upgradesById = {}
local upgradesByBranch = {}

for _, upgrade in ipairs(allUpgrades) do
	upgradesById[upgrade.id] = upgrade
	upgradesByBranch[upgrade.branch] = upgradesByBranch[upgrade.branch] or {}
	table.insert(upgradesByBranch[upgrade.branch], upgrade)
end

local function sanitizeUpgradesTable(upgradesTable)
	if typeof(upgradesTable) ~= "table" then
		return {}
	end

	return upgradesTable
end

function UpgradeConfig.GetAllUpgrades()
	return allUpgrades
end

function UpgradeConfig.GetUpgradesByBranch(branch)
	if typeof(branch) ~= "string" then
		return {}
	end

	return upgradesByBranch[branch] or {}
end

function UpgradeConfig.GetUpgradeById(id)
	if typeof(id) ~= "string" then
		return nil
	end

	return upgradesById[id]
end

function UpgradeConfig.GetCost(upgradeId, currentLevel)
	local def = UpgradeConfig.GetUpgradeById(upgradeId)
	if not def then
		return nil
	end

	local nextLevel = math.max((currentLevel or 0) + 1, 1)
	return def.baseCost * (def.costScale ^ (nextLevel - 1))
end

function UpgradeConfig.GetLevel(upgradesTable, upgradeId)
	local sanitized = sanitizeUpgradesTable(upgradesTable)
	local level = sanitized[upgradeId]
	if typeof(level) ~= "number" then
		return 0
	end

	return math.max(level, 0)
end

function UpgradeConfig.IsMaxed(upgradesTable, upgradeId)
	local def = UpgradeConfig.GetUpgradeById(upgradeId)
	if not def then
		return false
	end

	local level = UpgradeConfig.GetLevel(upgradesTable, upgradeId)
	return level >= def.maxLevel
end

function UpgradeConfig.GetStorageTier(upgradesTable)
	local sanitized = sanitizeUpgradesTable(upgradesTable)
	local highest = 0

	for _, upgrade in ipairs(UpgradeConfig.GetUpgradesByBranch("STORAGE")) do
		local level = sanitized[upgrade.id]
		if typeof(level) == "number" and level >= 1 then
			local effect = upgrade.effect(level)
			if effect.storageTier then
				highest = math.max(highest, effect.storageTier)
			end
		end
	end

	return highest
end

function UpgradeConfig.MeetsRequirements(upgradesTable, upgradeId)
	local def = UpgradeConfig.GetUpgradeById(upgradeId)
	if not def then
		return false
	end

	local requirements = def.requires
	if not requirements then
		return true
	end

	local sanitized = sanitizeUpgradesTable(upgradesTable)

	if requirements.storageTier then
		local tier = UpgradeConfig.GetStorageTier(sanitized)
		if tier < requirements.storageTier then
			return false
		end
	end

	if requirements.requiresUpgradeId then
		local requiredLevel = UpgradeConfig.GetLevel(sanitized, requirements.requiresUpgradeId)
		if requiredLevel < 1 then
			return false
		end
	end

	return true
end

return UpgradeConfig
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="9">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Folder" referent="10">
      <Properties>
        <string name="Name">Server</string>
      </Properties>
      <Item class="ModuleScript" referent="11">
        <Properties>
          <string name="Name">AnalyticsLogger</string>
          <string name="Source"><![CDATA[local AnalyticsService = game:GetService("AnalyticsService")
local RunService = game:GetService("RunService")

local AnalyticsLogger = {}

local function isStudio()
	return RunService:IsStudio()
end

local function clampNumber(value, default)
	if typeof(value) ~= "number" then
		return default
	end
	return value
end

local function logCustomEvent(player: Player?, eventName: string, value, customFields)
	if isStudio() then
		return
	end

	local sanitizedEvent = typeof(eventName) == "string" and eventName or ""
	if sanitizedEvent == "" then
		return
	end

	task.spawn(function()
		local ok, err = pcall(function()
			AnalyticsService:LogCustomEvent(player, sanitizedEvent, value or 1, customFields)
		end)

		if not ok then
			warn("[AnalyticsLogger] Failed to log custom event", sanitizedEvent, err)
		end
	end)
end

function AnalyticsLogger.LogOfflineSession(player: Player?, amount: number, hadBoosts: boolean, prestigeLevel: number, timeAwaySeconds: number, sessionDuration: number?)
	if isStudio() then
		return
	end

	if typeof(amount) ~= "number" or amount <= 0 then
		return
	end

	local payload = {
		OfflineAmount = clampNumber(amount, 0),
		HadBoosts = hadBoosts == true,
		PrestigeLevel = clampNumber(prestigeLevel, 0),
		TimeAwaySeconds = math.max(0, clampNumber(timeAwaySeconds, 0)),
		SessionDuration = math.max(0, clampNumber(sessionDuration or 0, 0)),
	}

	logCustomEvent(player, "OfflineEarningsSession", 1, payload)
end

return AnalyticsLogger
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="12">
        <Properties>
          <string name="Name">AutomationService</string>
          <string name="Source"><![CDATA[local Players = game:GetService("Players")

local PlayerDataService = require(script.Parent.PlayerDataService)
local UpgradeService = require(script.Parent.UpgradeService)
local UpgradeConfig = require(game:GetService("ReplicatedStorage").Shared.UpgradeConfig)
local AutomationConfig = require(game:GetService("ReplicatedStorage").Shared.AutomationConfig)

local AutomationService = {}

local CHECK_INTERVAL = 2
local automationSettings = {}
local automationById = {}
local automationOrder = {}
local branchByAutomation = {
	auto_cpu = "CPU",
	auto_ram = "RAM",
}

for _, definition in ipairs(AutomationConfig.GetAll()) do
	automationById[definition.id] = definition
	table.insert(automationOrder, definition.id)
end

local function getPlayerSettings(player)
	local settings = automationSettings[player]
	if not settings then
		settings = {}
		automationSettings[player] = settings
	end
	return settings
end

local function isAutomationEnabled(player, automation)
	local settings = getPlayerSettings(player)
	local value = settings[automation.id]
	if value == nil then
		return automation.enabledByDefault
	end
	return value
end

local function isAutomationUnlocked(playerData, automation)
	local requirements = automation.unlockRequirement
	if not requirements then
		return true
	end

	if requirements.storageTier then
		local tier = UpgradeConfig.GetStorageTier(playerData.upgrades or {})
		if tier < requirements.storageTier then
			return false
		end
	end

	return true
end

local function selectCheapestUpgrade(branch, playerData)
	local definitions = UpgradeConfig.GetUpgradesByBranch(branch)
	local owned = playerData.upgrades or {}
	local currency = typeof(playerData.data) == "number" and playerData.data or 0

	local choiceId
	local choiceCost

	for _, upgrade in ipairs(definitions) do
		if not UpgradeConfig.IsMaxed(owned, upgrade.id) and UpgradeConfig.MeetsRequirements(owned, upgrade.id) then
			local level = UpgradeConfig.GetLevel(owned, upgrade.id)
			local cost = UpgradeConfig.GetCost(upgrade.id, level)
			if typeof(cost) == "number" and currency >= cost then
				if not choiceCost or cost < choiceCost then
					choiceCost = cost
					choiceId = upgrade.id
				end
			end
		end
	end

	return choiceId
end

local function tryAutomationPurchase(player, automationId, playerData)
	local automation = automationById[automationId]
	if not automation or not isAutomationEnabled(player, automation) then
		return playerData
	end

	if not isAutomationUnlocked(playerData, automation) then
		return playerData
	end

	local branch = branchByAutomation[automationId]
	if not branch then
		return playerData
	end

	local upgradeId = selectCheapestUpgrade(branch, playerData)
	if not upgradeId then
		return playerData
	end

	local success = UpgradeService.Buy(player, upgradeId)
	if success then
		return PlayerDataService.Get(player)
	end

	return playerData
end

local function processPlayerAutomation(player)
	local playerData = PlayerDataService.Get(player)
	if typeof(playerData) ~= "table" then
		return
	end

	for _, automationId in ipairs(automationOrder) do
		playerData = tryAutomationPurchase(player, automationId, playerData)
	end
end

local function automationLoop()
	while true do
		task.wait(CHECK_INTERVAL)
		for player in pairs(automationSettings) do
			if player and player.Parent then
				processPlayerAutomation(player)
			else
				automationSettings[player] = nil
			end
		end
	end
end

function AutomationService.SetEnabled(player, automationId, enabled)
	local automation = automationById[automationId]
	if not automation then
		return
	end

	local settings = getPlayerSettings(player)
	settings[automationId] = enabled and true or false
end

function AutomationService.Init()
	if AutomationService._initialized then
		return
	end
	AutomationService._initialized = true

	Players.PlayerAdded:Connect(function(player)
		getPlayerSettings(player)
	end)

	Players.PlayerRemoving:Connect(function(player)
		automationSettings[player] = nil
	end)

	for _, player in ipairs(Players:GetPlayers()) do
		getPlayerSettings(player)
	end

	task.spawn(automationLoop)
end

return AutomationService
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="13">
        <Properties>
          <string name="Name">BoostManager</string>
          <string name="Source"><![CDATA[local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local PlayerDataService = require(script.Parent.PlayerDataService)
local BoostService = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("BoostService"))

local BoostManager = {}

local UPDATE_INTERVAL = 1

local remotesFolder = ReplicatedStorage:FindFirstChild("Remotes")
if not remotesFolder or not remotesFolder:IsA("Folder") then
	remotesFolder = Instance.new("Folder")
	remotesFolder.Name = "Remotes"
	remotesFolder.Parent = ReplicatedStorage
end

local boostEvent = remotesFolder:FindFirstChild("BoostsUpdated")
if not boostEvent or not boostEvent:IsA("RemoteEvent") then
	if boostEvent then
		boostEvent:Destroy()
	end
	boostEvent = Instance.new("RemoteEvent")
	boostEvent.Name = "BoostsUpdated"
	boostEvent.Parent = remotesFolder
end

local activePlayers: { [Player]: boolean } = {}
local multiplierCache: { [Player]: { multiplier: number, boosts: { [string]: number } } } = {}
local accumulatedTime = 0

local function shallowCopy(source)
	local target = {}
	for key, value in pairs(source) do
		target[key] = value
	end
	return target
end

local function ensureBoostTable(dataTable)
	if typeof(dataTable.boosts) ~= "table" then
		dataTable.boosts = {}
	end
	return dataTable.boosts
end

local function trimExpiredBoosts(boosts)
	local now = os.time()
	local changed = false
	for boostName, expiration in pairs(boosts) do
		if typeof(expiration) ~= "number" or expiration <= now then
			boosts[boostName] = nil
			changed = true
		end
	end
	return changed
end

local function computeMultiplier(boosts)
	local total = 1
	for boostName in pairs(boosts) do
		local definition = BoostService.GetDefinition(boostName)
		if definition and typeof(definition.multiplier) == "number" then
			total *= definition.multiplier
		end
	end
	return total
end

local function dispatchUpdate(player, boosts, multiplier)
	if not boostEvent then
		return
	end
	boostEvent:FireClient(player, shallowCopy(boosts), multiplier)
end

local function refreshPlayerBoosts(player)
	local playerData = PlayerDataService.Get(player)
	if typeof(playerData) ~= "table" then
		return
	end

	local boosts = ensureBoostTable(playerData)
	local expiredRemoved = trimExpiredBoosts(boosts)
	local multiplier = computeMultiplier(boosts)

	local cached = multiplierCache[player]
	local dirty = expiredRemoved

	if cached then
		if cached.multiplier ~= multiplier then
			dirty = true
		else
			for boostName, expiration in pairs(boosts) do
				if cached.boosts[boostName] ~= expiration then
					dirty = true
					break
				end
			end

			if not dirty then
				for boostName in pairs(cached.boosts) do
					if boosts[boostName] == nil then
						dirty = true
						break
					end
				end
			end
		end
	else
		dirty = true
	end

	if dirty then
		PlayerDataService.Set(player, playerData)
		multiplierCache[player] = {
			multiplier = multiplier,
			boosts = shallowCopy(boosts),
		}
		dispatchUpdate(player, boosts, multiplier)
	end
end

function BoostManager.AddBoost(player, boostName)
	local definition = BoostService.GetDefinition(boostName)
	if not definition then
		warn("[BoostManager] Invalid boost:", boostName)
		return
	end
	return BoostManager.AddBoostDuration(player, boostName, definition.duration)
end

function BoostManager.AddBoostDuration(player, boostName, duration)
	if typeof(duration) ~= "number" or duration <= 0 then
		return
	end

	local playerData = PlayerDataService.Get(player)
	if typeof(playerData) ~= "table" then
		return
	end

	local boosts = ensureBoostTable(playerData)
	local now = os.time()

	local existingExpiration = boosts[boostName]
	if typeof(existingExpiration) ~= "number" or existingExpiration < now then
		existingExpiration = now
	end

	boosts[boostName] = existingExpiration + duration
	PlayerDataService.Set(player, playerData)
	refreshPlayerBoosts(player)
end

function BoostManager.GetMultiplier(player)
	local cached = multiplierCache[player]
	if cached then
		return cached.multiplier
	end
	return 1
end

function BoostManager.GetBoosts(player)
	local cached = multiplierCache[player]
	if cached then
		return shallowCopy(cached.boosts)
	end

	local data = PlayerDataService.Get(player)
	if typeof(data) ~= "table" then
		return {}
	end

	return shallowCopy(ensureBoostTable(data))
end

local function trackPlayer(player)
	activePlayers[player] = true
	refreshPlayerBoosts(player)
end

local function untrackPlayer(player)
	activePlayers[player] = nil
	multiplierCache[player] = nil
end

Players.PlayerAdded:Connect(trackPlayer)
Players.PlayerRemoving:Connect(untrackPlayer)

for _, player in ipairs(Players:GetPlayers()) do
	trackPlayer(player)
end

RunService.Heartbeat:Connect(function(deltaTime)
	accumulatedTime += deltaTime
	if accumulatedTime < UPDATE_INTERVAL then
		return
	end
	accumulatedTime -= UPDATE_INTERVAL

	for player in pairs(activePlayers) do
		if player and player.Parent then
			refreshPlayerBoosts(player)
		else
			activePlayers[player] = nil
			multiplierCache[player] = nil
		end
	end
end)

return BoostManager
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="14">
        <Properties>
          <string name="Name">EconomyAnalytics</string>
          <string name="Source"><![CDATA[local AnalyticsService = game:GetService("AnalyticsService")
local RunService = game:GetService("RunService")

local EconomyAnalytics = {}

local CURRENCY_NAME = "Data"

local function sanitizeAmount(amount)
	if typeof(amount) ~= "number" or amount <= 0 then
		return nil
	end
	return amount
end

local function sanitizeBalance(balance)
	if typeof(balance) ~= "number" then
		return 0
	end
	return math.max(balance, 0)
end

local function sanitizeSku(sku)
	if typeof(sku) == "string" and sku ~= "" then
		return sku
	end
	return nil
end

local function resolveTransactionType(transactionType)
	if typeof(transactionType) == "string" then
		return transactionType
	end

	if typeof(transactionType) == "EnumItem" then
		return transactionType.Name
	end

	return "Gameplay"
end

local function logEconomyEvent(player, flowType, transactionType, amount, balanceAfter, sku, customFields)
	if RunService:IsStudio() then
		return
	end

	local sanitizedAmount = sanitizeAmount(amount)
	if not sanitizedAmount then
		return
	end

	local sanitizedBalance = sanitizeBalance(balanceAfter)
	local sanitizedSku = sanitizeSku(sku)

	local success, err = pcall(function()
		AnalyticsService:LogEconomyEvent(
			player,
			flowType,
			CURRENCY_NAME,
			sanitizedAmount,
			sanitizedBalance,
			resolveTransactionType(transactionType),
			sanitizedSku or "",
			customFields
		)
	end)

	if not success then
		warn("[EconomyAnalytics] Failed to log economy event:", err)
	end
end

function EconomyAnalytics.LogSource(player, amount, balanceAfter, transactionType, sku, customFields)
	if not player then
		return
	end

	logEconomyEvent(
		player,
		Enum.AnalyticsEconomyFlowType.Source,
		transactionType or Enum.AnalyticsEconomyTransactionType.Gameplay,
		amount,
		balanceAfter,
		sku,
		customFields
	)
end

function EconomyAnalytics.LogSink(player, cost, balanceAfter, transactionType, sku, customFields)
	if not player then
		return
	end

	logEconomyEvent(
		player,
		Enum.AnalyticsEconomyFlowType.Sink,
		transactionType or Enum.AnalyticsEconomyTransactionType.Shop,
		cost,
		balanceAfter,
		sku,
		customFields
	)
end

return EconomyAnalytics
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="15">
        <Properties>
          <string name="Name">GameServer</string>
          <token name="RunContext">0</token>
          <string name="Source"><![CDATA[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local AnalyticsService = game:GetService("AnalyticsService")

local REMOTES_FOLDER_NAME = "Remotes"
local PLAYER_GUI_WAIT_TIME = 5
local PRESTIGE_OFFLINE_STEP = 0.1

local remotesFolder = ReplicatedStorage:FindFirstChild("Remotes")
if not remotesFolder or not remotesFolder:IsA("Folder") then
	remotesFolder = Instance.new("Folder")
	remotesFolder.Name = REMOTES_FOLDER_NAME
	remotesFolder.Parent = ReplicatedStorage
end

local function ensureRemote(instanceClass, name)
	local existing = remotesFolder:FindFirstChild(name)
	if existing and existing:IsA(instanceClass) then
		return existing
	end

	if existing then
		existing:Destroy()
	end

	local remote = Instance.new(instanceClass)
	remote.Name = name
	remote.Parent = remotesFolder
	return remote
end

local requestSync = ensureRemote("RemoteFunction", "RequestSync")
local buyUpgradeEvent = ensureRemote("RemoteEvent", "RequestBuyUpgrade")
local prestigeEvent = ensureRemote("RemoteEvent", "RequestPrestige")
local saveStatusEvent = ensureRemote("RemoteEvent", "SaveStatus")
local storeAnalyticsEvent = ensureRemote("RemoteEvent", "StoreAnalyticsEvent")
local offlinePreviewEvent = ensureRemote("RemoteEvent", "OfflineEarningsPreview")
local loadingProgressEvent = ensureRemote("RemoteEvent", "LoadingProgress")

local PlayerDataService = require(script.Parent.PlayerDataService)
local ProductionService = require(script.Parent.ProductionService)
local UpgradeService = require(script.Parent.UpgradeService)
local PrestigeService = require(script.Parent.PrestigeService)
local EconomyAnalytics = require(script.Parent.EconomyAnalytics)
local OfflineProgress = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("OfflineProgress"))
local AnalyticsLogger = require(script.Parent.AnalyticsLogger)

local activePlayers = {}
local productionLoopStarted = false
local productionConnection
local autosaveFlags = {}
local storeStateByPlayer = {}
local storePlatformByPlayer = {}
local offlinePreviewSent = {}
local sessionInfo = {}

local AUTOSAVE_INTERVAL = 60

local function savePlayerWithStatus(player)
	if not player then
		return
	end

	if saveStatusEvent then
		saveStatusEvent:FireClient(player, "saving")
	end

	local success = PlayerDataService.Save(player)

	if saveStatusEvent then
		if success then
			saveStatusEvent:FireClient(player, "saved")
		else
			saveStatusEvent:FireClient(player, "offline")
		end
	end

	return success
end

local function startAutosave(player)
	if autosaveFlags[player] then
		return
	end

	autosaveFlags[player] = true

	task.spawn(function()
		while autosaveFlags[player] do
			task.wait(AUTOSAVE_INTERVAL)
			if not autosaveFlags[player] then
				break
			end

			if player and player.Parent then
				savePlayerWithStatus(player)
			else
				autosaveFlags[player] = nil
				break
			end
		end
	end)
end

local function stopAutosave(player)
	autosaveFlags[player] = nil
end

local function applyOfflineProgress(player, playerData)
	if typeof(playerData) ~= "table" then
		return
	end

	local baseProduction = ProductionService.GetBaseDataPerSecond(player)
	if typeof(baseProduction) ~= "number" or baseProduction <= 0 then
		playerData.lastSeen = os.time()
		PlayerDataService.Set(player, playerData)
		return
	end

	local now = os.time()
	local lastSeen = typeof(playerData.lastSeen) == "number" and math.max(playerData.lastSeen, 0) or now
	local timeAway = math.max(0, now - lastSeen)
	local gain, _, hadOfflineBoosts, baseAmount, boostedAmount = OfflineProgress.Calculate(playerData, baseProduction, now)
	local prestigeLevel = typeof(playerData.prestige) == "number" and math.max(playerData.prestige, 0) or 0
	local prestigeMultiplier = 1 + (prestigeLevel * PRESTIGE_OFFLINE_STEP)

	local totalGain = gain * prestigeMultiplier
	local totalBase = baseAmount * prestigeMultiplier
	local totalBoosted = boostedAmount * prestigeMultiplier

	if totalGain > 0 then
		sessionInfo[player] = sessionInfo[player] or {}
		sessionInfo[player].lastOfflineEarnings = {
			total = totalGain,
			hadBoosts = hadOfflineBoosts == true,
			prestige = prestigeLevel,
			timeAway = timeAway,
		}
	end

	if totalGain > 0 then
		playerData.data = math.max(0, (playerData.data or 0) + totalGain)
	end

	PlayerDataService.Set(player, playerData)

	if totalGain > 0 then
		EconomyAnalytics.LogSource(
			player,
			totalGain,
			playerData.data,
			Enum.AnalyticsEconomyTransactionType.TimedReward,
			"OfflineEarnings",
			{
				BoostType = "Offline",
				PrestigeLevel = playerData.prestige or 0,
			}
		)

		if offlinePreviewEvent and not offlinePreviewSent[player] then
			local playerGui = player:FindFirstChildOfClass("PlayerGui") or player:FindFirstChild("PlayerGui")
			if not playerGui then
				playerGui = player:WaitForChild("PlayerGui", PLAYER_GUI_WAIT_TIME)
			end

			if playerGui then
				local terminalUi = playerGui:FindFirstChild("TerminalUI")
				if not terminalUi then
					terminalUi = playerGui:WaitForChild("TerminalUI", PLAYER_GUI_WAIT_TIME)
				end

				if terminalUi then
					offlinePreviewSent[player] = true
					offlinePreviewEvent:FireClient(player, {
						totalAmount = totalGain,
						baseAmount = totalBase,
						boostedAmount = totalBoosted,
						hadBoosts = hadOfflineBoosts == true,
						prestigeMultiplier = prestigeMultiplier,
					})
				end
			end
		end
	end
end

local function fireLoadingProgress(player, message, progress)
	if not loadingProgressEvent then
		return
	end

	loadingProgressEvent:FireClient(player, message, progress)
end

local function initPlayerData(player)
	local initMethod = PlayerDataService and PlayerDataService.InitPlayer

	if typeof(initMethod) ~= "function" and PlayerDataService then
		-- Backwards compatibility with older PlayerDataService exports.
		initMethod = PlayerDataService.Init or PlayerDataService.Get
	end

	if typeof(initMethod) ~= "function" then
		warn("[GameServer] PlayerDataService is missing an initializer; using empty data for", player)
		return {}
	end

	local ok, playerData = pcall(initMethod, player)
	if not ok then
		warn("[GameServer] PlayerDataService failed to load data for", player, playerData)
		return {}
	end

	if typeof(playerData) ~= "table" then
		return {}
	end

	return playerData
end

local function addPlayer(player)
	fireLoadingProgress(player, "Loading data", 0.25)

	local playerData = initPlayerData(player)
	player:SetAttribute("StorePlatform", player:GetAttribute("StorePlatform") or "Unknown")
	sessionInfo[player] = {
		joinTime = os.time(),
	}

	fireLoadingProgress(player, "Applying offline earnings", 0.5)

	applyOfflineProgress(player, playerData)

	fireLoadingProgress(player, "Syncing boosts", 0.75)

	activePlayers[player] = true
	startAutosave(player)

	fireLoadingProgress(player, "Finalizing", 1)
end

local function removePlayer(player)
	activePlayers[player] = nil
	stopAutosave(player)
	savePlayerWithStatus(player)
	PlayerDataService.Release(player)
	storeStateByPlayer[player] = nil
	storePlatformByPlayer[player] = nil
	offlinePreviewSent[player] = nil
	sessionInfo[player] = nil
end

local validStoreEventTypes = {
	StoreOpened = true,
	StoreClosed = true,
	ItemClicked = true,
	PurchasePromptShown = true,
}

local function logStoreAnalytics(player, eventName, payload)
	local enriched = table.clone(payload)
	enriched.UserId = player and player.UserId or 0

	local ok, err = pcall(function()
		AnalyticsService:LogCustomEvent(player, eventName, 1, enriched)
	end)

	if not ok then
		warn("[GameServer] Failed to log store analytics:", err)
	end
end

storeAnalyticsEvent.OnServerEvent:Connect(function(player, payload)
	if typeof(payload) ~= "table" then
		return
	end

	local eventName = payload.Event
	if typeof(eventName) ~= "string" or not validStoreEventTypes[eventName] then
		return
	end

	local platform = typeof(payload.Platform) == "string" and payload.Platform or nil
	if platform then
		storePlatformByPlayer[player] = platform
		player:SetAttribute("StorePlatform", platform)
	end

	if eventName == "StoreOpened" then
		if storeStateByPlayer[player] then
			return
		end
		storeStateByPlayer[player] = true
	elseif eventName == "StoreClosed" then
		if storeStateByPlayer[player] == false then
			return
		end
		storeStateByPlayer[player] = false
	end

	local data = {
		ItemName = tostring(payload.ItemName or ""),
		ProductType = tostring(payload.ProductType or ""),
		ProductId = typeof(payload.ProductId) == "number" and payload.ProductId or 0,
		Platform = storePlatformByPlayer[player] or "Unknown",
	}

	logStoreAnalytics(player, "Store" .. eventName, data)
end)

local function applyProduction(player, deltaTime)
	if deltaTime <= 0 then
		return nil, nil
	end

	local playerData = PlayerDataService.Get(player)
	if typeof(playerData) ~= "table" then
		return nil, nil
	end

	local dps = ProductionService.GetDataPerSecond(player)
	if typeof(dps) ~= "number" or dps <= 0 then
		return nil, nil
	end

	-- Accumulate DPS using delta time so production remains smooth and frame-rate independent.
	local added = dps * deltaTime
	playerData.data = math.max((playerData.data or 0) + added, 0)
	PlayerDataService.Set(player, playerData)

	return dps, added
end

local function startProductionLoop()
	if productionLoopStarted or productionConnection then
		return
	end
	productionLoopStarted = true

	productionConnection = RunService.Heartbeat:Connect(function(deltaTime)
		if deltaTime <= 0 then
			return
		end

		for player in pairs(activePlayers) do
			if player and player.Parent then
				applyProduction(player, deltaTime)
			else
				activePlayers[player] = nil
			end
		end
	end)
end

requestSync.OnServerInvoke = function(player)
	local data = PlayerDataService.Get(player)
	if typeof(data) ~= "table" then
		return nil
	end

	local state = table.clone(data)
	local dps = ProductionService.GetDataPerSecond(player)
	state.dps = typeof(dps) == "number" and dps or 0

	return state
end

buyUpgradeEvent.OnServerEvent:Connect(function(player, payload)
	if not player then
		return
	end

	local upgradeId = payload
	local mode = "single"

	if typeof(payload) == "table" then
		upgradeId = payload.upgradeId
		if payload.mode == "max" then
			mode = "max"
		end
	end

	if typeof(upgradeId) ~= "string" then
		return
	end

	if mode == "max" then
		UpgradeService.BuyMax(player, upgradeId)
	else
		UpgradeService.Buy(player, upgradeId)
	end
end)

prestigeEvent.OnServerEvent:Connect(function(player)
	if not player then
		return
	end

	PrestigeService.Prestige(player)
end)

local function onPlayerRemoving(player)
	local info = sessionInfo[player]
	if info and info.lastOfflineEarnings then
		local sessionDuration = 0
		if typeof(info.joinTime) == "number" then
			sessionDuration = math.max(0, os.time() - info.joinTime)
		end

		AnalyticsLogger.LogOfflineSession(
			player,
			info.lastOfflineEarnings.total,
			info.lastOfflineEarnings.hadBoosts,
			info.lastOfflineEarnings.prestige,
			info.lastOfflineEarnings.timeAway,
			sessionDuration
		)
	end

	removePlayer(player)
end

Players.PlayerAdded:Connect(addPlayer)
Players.PlayerRemoving:Connect(onPlayerRemoving)

for _, player in Players:GetPlayers() do
	addPlayer(player)
end

startProductionLoop()

game:BindToClose(function()
	for _, player in Players:GetPlayers() do
		savePlayerWithStatus(player)
		PlayerDataService.Release(player)
	end
end)
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="16">
        <Properties>
          <string name="Name">GroupBonusService</string>
          <string name="Source"><![CDATA[local GroupBonusService = {}

local GROUP_ID = 1_032_797_065 -- Arcadi Games
local GROUP_MULTIPLIER = 1.10

local membershipCache = {}

local function checkMembership(player)
	if membershipCache[player] ~= nil then
		return membershipCache[player]
	end

	local success, isInGroup = pcall(function()
		return player:IsInGroup(GROUP_ID)
	end)

	if not success then
		warn("[GroupBonusService] Failed to check group membership for", player, isInGroup)
		isInGroup = false
	end

	membershipCache[player] = isInGroup
	return isInGroup
end

function GroupBonusService.IsInGroup(player)
	return checkMembership(player)
end

function GroupBonusService.GetGroupMultiplier(player)
	return checkMembership(player) and GROUP_MULTIPLIER or 1.0
end

function GroupBonusService.Release(player)
	membershipCache[player] = nil
end

return GroupBonusService
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="17">
        <Properties>
          <string name="Name">MilestoneService</string>
          <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local PlayerDataService = require(script.Parent.PlayerDataService)
local UpgradeConfig = require(ReplicatedStorage.Shared.UpgradeConfig)

local MilestoneService = {}

local remotesFolder = ReplicatedStorage:FindFirstChild("Remotes")
local milestoneRemote = remotesFolder and remotesFolder:FindFirstChild("MilestoneNotification")

type PlayerState = {
	data: number?,
	upgrades: { [string]: number }?,
	prestige: number?,
	corePower: number?,
	milestones: { [string]: boolean }?,
}

local milestones = {
	{
		id = "storage_tier_2",
		description = "Reach Storage Tier II",
		condition = function(state: PlayerState)
			return UpgradeConfig.GetStorageTier(state.upgrades or {}) >= 2
		end,
		reward = function(state: PlayerState)
			state.data = (state.data or 0) + 10_000
		end,
		message = "Storage Tier II unlocked! Bonus 10,000 Data.",
	},
	{
		id = "storage_tier_3",
		description = "Reach Storage Tier III",
		condition = function(state: PlayerState)
			return UpgradeConfig.GetStorageTier(state.upgrades or {}) >= 3
		end,
		reward = function(state: PlayerState)
			state.corePower = (state.corePower or 0) + 1
		end,
		message = "Storage Tier III unlocked! +1 Core Power.",
	},
	{
		id = "first_prestige",
		description = "Complete your first Prestige",
		condition = function(state: PlayerState)
			return (state.prestige or 0) >= 1
		end,
		reward = function(state: PlayerState)
			state.data = (state.data or 0) + 50_000
		end,
		message = "First Prestige complete! Bonus 50,000 Data.",
	},
}

local function ensureMilestoneTable(state: PlayerState)
	if typeof(state.milestones) ~= "table" then
		state.milestones = {}
	end
	return state.milestones
end

local function notifyClient(player, milestoneId, message)
	if milestoneRemote then
		milestoneRemote:FireClient(player, milestoneId, message)
	end
end

local function applyMilestones(player, state: PlayerState)
	local completed = ensureMilestoneTable(state)
	local changed = false

	for _, milestone in ipairs(milestones) do
		if not completed[milestone.id] and milestone.condition(state) then
			if milestone.reward then
				milestone.reward(state)
			end
			completed[milestone.id] = true
			changed = true
			notifyClient(player, milestone.id, milestone.message or milestone.description)
		end
	end

	if changed then
		PlayerDataService.Set(player, state)
	end
end

function MilestoneService.CheckMilestones(player)
	local state = PlayerDataService.Get(player)
	if typeof(state) ~= "table" then
		return
	end

	applyMilestones(player, state)
end

return MilestoneService
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="18">
        <Properties>
          <string name="Name">PlayerDataService</string>
          <string name="Source"><![CDATA[local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")

local PlayerDataService = {}

local DATASTORE_NAME = "PlayerProgress"
local MAX_RETRIES = 3
local RETRY_DELAY = 2

local defaultData = {
	data = 0,
	upgrades = {},
	prestige = 0,
	corePower = 0,
	currency = 0,
	boosts = {},
	ownedPasses = {},
	lastSeen = 0,
}

local playerCache = {}
local dataStore = DataStoreService:GetDataStore(DATASTORE_NAME)
local listenersInitialized = false

local function deepCopy(source)
	local target = {}
	for key, value in source do
		if typeof(value) == "table" then
			target[key] = deepCopy(value)
		else
			target[key] = value
		end
	end
	return target
end

local function deepMerge(base, overrides)
	local merged = deepCopy(base)
	if typeof(overrides) ~= "table" then
		return merged
	end

	for key, value in overrides do
		if value ~= nil then
			if typeof(value) == "table" and typeof(merged[key]) == "table" then
				merged[key] = deepMerge(merged[key], value)
			elseif typeof(value) == "table" then
				merged[key] = deepCopy(value)
			else
				merged[key] = value
			end
		end
	end

	return merged
end

local function sanitizeUpgrades(upgrades)
	if typeof(upgrades) ~= "table" then
		return {}
	end

	local cleaned = {}
	for upgradeId, level in upgrades do
		if typeof(upgradeId) == "string" and typeof(level) == "number" then
			cleaned[upgradeId] = level
		end
	end

	return cleaned
end

local function sanitizeBoosts(boosts)
	if typeof(boosts) ~= "table" then
		return {}
	end

	local cleaned = {}
	local now = os.time()

	for boostName, expiration in boosts do
		if typeof(boostName) == "string" and typeof(expiration) == "number" and expiration > now then
			cleaned[boostName] = expiration
		end
	end

	return cleaned
end

local function sanitizeOwnedPasses(passes)
	if typeof(passes) ~= "table" then
		return {}
	end

	local cleaned = {}
	for passId, owned in passes do
		if typeof(passId) == "string" and typeof(owned) == "boolean" then
			cleaned[passId] = owned
		elseif typeof(passId) == "number" and typeof(owned) == "boolean" then
			cleaned[tostring(passId)] = owned
		end
	end

	return cleaned
end

local function sanitizeData(payload)
	local sanitized = deepCopy(defaultData)

	if typeof(payload) ~= "table" then
		return sanitized
	end

	if typeof(payload.data) == "number" then
		sanitized.data = payload.data
	end

	sanitized.upgrades = sanitizeUpgrades(payload.upgrades)

	if typeof(payload.prestige) == "number" then
		sanitized.prestige = payload.prestige
	end

	if typeof(payload.corePower) == "number" then
		sanitized.corePower = payload.corePower
	end

	if typeof(payload.currency) == "number" then
		sanitized.currency = math.max(0, payload.currency)
	end

	sanitized.boosts = sanitizeBoosts(payload.boosts)
	sanitized.ownedPasses = sanitizeOwnedPasses(payload.ownedPasses)
	if typeof(payload.lastSeen) == "number" then
		sanitized.lastSeen = payload.lastSeen
	else
		sanitized.lastSeen = os.time()
	end

	return sanitized
end

local function loadDataWithRetries(userId)
	local attempts = 0
	local lastError

	repeat
		attempts += 1
		local success, stored = pcall(function()
			return dataStore:GetAsync(userId)
		end)

		if success then
			return sanitizeData(stored)
		end

		lastError = stored
		warn("[PlayerDataService] GetAsync failed for", userId, lastError)
		if attempts < MAX_RETRIES then
			task.wait(RETRY_DELAY)
		end
	until attempts >= MAX_RETRIES

	return sanitizeData(nil)
end

local function saveDataWithRetries(userId, data)
	local attempts = 0
	local lastError

	repeat
		attempts += 1
		local success, err = pcall(function()
			dataStore:SetAsync(userId, data)
		end)

		if success then
			return true
		end

		lastError = err
		warn("[PlayerDataService] SetAsync failed for", userId, lastError)
		if attempts < MAX_RETRIES then
			task.wait(RETRY_DELAY)
		end
	until attempts >= MAX_RETRIES

	return false, lastError
end

function PlayerDataService.InitPlayer(player)
	local userId = tostring(player.UserId)
	if playerCache[userId] then
		return playerCache[userId]
	end

	local data = loadDataWithRetries(userId)
	playerCache[userId] = data

	return data
end

function PlayerDataService.Get(player)
	local userId = tostring(player.UserId)
	if playerCache[userId] then
		return playerCache[userId]
	end

	return PlayerDataService.InitPlayer(player)
end

function PlayerDataService.Set(player, newData)
	if typeof(newData) ~= "table" then
		warn("[PlayerDataService] Attempt to set invalid data for", player)
		return
	end

	local userId = tostring(player.UserId)
	local merged = deepMerge(playerCache[userId] or defaultData, newData)
	playerCache[userId] = sanitizeData(merged)
end

function PlayerDataService.Save(player)
	local userId = tostring(player.UserId)
	local cached = playerCache[userId]

	if not cached then
		return false
	end

	cached.lastSeen = os.time()

	local success = saveDataWithRetries(userId, cached)
	return success
end

function PlayerDataService.Release(player)
	local userId = tostring(player.UserId)
	playerCache[userId] = nil
end

local function setupListeners()
	if listenersInitialized then
		return
	end
	listenersInitialized = true

	Players.PlayerAdded:Connect(function(player)
		PlayerDataService.InitPlayer(player)
	end)

	Players.PlayerRemoving:Connect(function(player)
		PlayerDataService.Save(player)
		PlayerDataService.Release(player)
	end)

	game:BindToClose(function()
		for _, player in ipairs(Players:GetPlayers()) do
			PlayerDataService.Save(player)
		end
	end)
end

setupListeners()

return PlayerDataService
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="19">
        <Properties>
          <string name="Name">PremiumBonusService</string>
          <string name="Source"><![CDATA[local PremiumBonusService = {}

local PREMIUM_MULTIPLIER = 1.25

local premiumCache = {}

local function cacheMembership(player)
	if premiumCache[player] ~= nil then
		return premiumCache[player]
	end

	local hasPremium = false

	if player then
		local success, result = pcall(function()
			return player.MembershipType == Enum.MembershipType.Premium
		end)

		if success then
			hasPremium = result
		else
			warn("[PremiumBonusService] Membership check failed for", player, result)
		end
	end

	premiumCache[player] = hasPremium
	return hasPremium
end

function PremiumBonusService.HasPremium(player)
	return cacheMembership(player)
end

function PremiumBonusService.GetPremiumMultiplier(player)
	return cacheMembership(player) and PREMIUM_MULTIPLIER or 1.0
end

function PremiumBonusService.Release(player)
	premiumCache[player] = nil
end

return PremiumBonusService
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="20">
        <Properties>
          <string name="Name">PrestigeService</string>
          <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local PlayerDataService = require(script.Parent.PlayerDataService)
local UpgradeConfig = require(ReplicatedStorage.Shared.UpgradeConfig)
local EconomyAnalytics = require(script.Parent.EconomyAnalytics)

local PrestigeService = {}

local REQUIRED_TIER = 3
local PRESTIGE_UNIT = 0.1
local PRESTIGE_MULTIPLIER = 1.15

local function getPlayerState(player)
	local state = PlayerDataService.Get(player)
	if typeof(state) ~= "table" then
		warn("[PrestigeService] Invalid player data for", player)
		return nil
	end

	if typeof(state.upgrades) ~= "table" then
		state.upgrades = {}
	end

	return state
end

function PrestigeService.CanPrestige(player)
	local state = getPlayerState(player)
	if not state then
		return false
	end

	local tier = UpgradeConfig.GetStorageTier(state.upgrades)
	return tier >= REQUIRED_TIER
end

function PrestigeService.Prestige(player)
	if not PrestigeService.CanPrestige(player) then
		return false
	end

	local state = getPlayerState(player)
	if not state then
		return false
	end

	local currentBonusUnits = typeof(state.corePower) == "number" and state.corePower or 0
	local currentMultiplier = 1 + (currentBonusUnits * PRESTIGE_UNIT)
	local newMultiplier = currentMultiplier * PRESTIGE_MULTIPLIER
	local newBonusUnits = math.max(((newMultiplier - 1) / PRESTIGE_UNIT), 0)

	local prestigeLevel = (state.prestige or 0) + 1
	local spentData = math.max(state.data or 0, 0)

	state.data = 0
	state.upgrades = {}
	state.prestige = prestigeLevel
	state.corePower = newBonusUnits

	PlayerDataService.Set(player, state)
	PlayerDataService.Save(player)

	if spentData > 0 then
		EconomyAnalytics.LogSink(
			player,
			spentData,
			state.data,
			Enum.AnalyticsEconomyTransactionType.Gameplay,
			"Prestige_Reset",
			{
				PrestigeLevel = prestigeLevel,
			}
		)
	end

	local gainedCore = math.max(newBonusUnits - currentBonusUnits, 0)
	if gainedCore > 0 then
		EconomyAnalytics.LogSource(
			player,
			gainedCore,
			state.corePower,
			Enum.AnalyticsEconomyTransactionType.Gameplay,
			"Prestige_CoreGain",
			{
				PrestigeLevel = prestigeLevel,
			}
		)
	end

	return true
end

return PrestigeService
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="21">
        <Properties>
          <string name="Name">ProductionService</string>
          <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local PlayerDataService = require(script.Parent.PlayerDataService)
local GroupBonusService = require(script.Parent.GroupBonusService)
local PremiumBonusService = require(script.Parent.PremiumBonusService)
local BoostManager = require(script.Parent.BoostManager)
local UpgradeConfig = require(ReplicatedStorage.Shared.UpgradeConfig)

local ProductionService = {}

local cpuUpgrades = UpgradeConfig.GetUpgradesByBranch("CPU")
local ramUpgrades = UpgradeConfig.GetUpgradesByBranch("RAM")

local BASE_DPS = 1
local PRESTIGE_BONUS = 0.1

local function getPlayerUpgrades(playerData)
	if typeof(playerData) ~= "table" then
		return nil
	end

	if typeof(playerData.upgrades) == "table" then
		return playerData.upgrades
	end

	return nil
end

local function getLevel(upgrades, upgradeId)
	if not upgrades then
		return 0
	end

	local level = upgrades[upgradeId]
	if typeof(level) ~= "number" then
		return 0
	end

	return math.max(level, 0)
end

local function accumulateCpuBonus(upgrades)
	local total = 0

	for _, upgrade in ipairs(cpuUpgrades) do
		local level = getLevel(upgrades, upgrade.id)
		if level > 0 then
			local effect = upgrade.effect(level)
			if effect and typeof(effect.flatDps) == "number" then
				total += effect.flatDps
			end
		end
	end

	return total
end

local function normalizeMultiplier(value)
	if typeof(value) ~= "number" then
		return 0
	end

	if value >= 1 then
		return value - 1
	end

	return value
end

local function accumulateRamMultiplier(upgrades)
	local totalMultiplier = 1

	for _, upgrade in ipairs(ramUpgrades) do
		local level = getLevel(upgrades, upgrade.id)
		if level > 0 then
			local effect = upgrade.effect(level)
			local bonus = normalizeMultiplier(effect and effect.multiplier)
			totalMultiplier *= (1 + bonus)
		end
	end

	return totalMultiplier
end

local function getPrestigeMultiplier(playerData)
	local corePower = typeof(playerData.corePower) == "number" and playerData.corePower or 0
	if corePower <= 0 then
		return 1
	end

	return 1 + (corePower * PRESTIGE_BONUS)
end

function ProductionService.GetBaseDataPerSecond(player)
	local playerData = PlayerDataService.Get(player)
	if typeof(playerData) ~= "table" then
		return BASE_DPS
	end

	local upgrades = getPlayerUpgrades(playerData)

	local totalFlat = accumulateCpuBonus(upgrades)
	local totalMultiplier = accumulateRamMultiplier(upgrades)
	local prestigeMultiplier = getPrestigeMultiplier(playerData)

	local groupMultiplier = GroupBonusService.GetGroupMultiplier(player)
	local premiumMultiplier = PremiumBonusService.GetPremiumMultiplier(player)

	return (BASE_DPS + totalFlat) * totalMultiplier * prestigeMultiplier * groupMultiplier * premiumMultiplier
end

function ProductionService.GetDataPerSecond(player)
	local baseProduction = ProductionService.GetBaseDataPerSecond(player)
	local boostMultiplier = BoostManager.GetMultiplier(player)
	return baseProduction * boostMultiplier
end

return ProductionService
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="22">
        <Properties>
          <string name="Name">StoreService</string>
          <string name="Source"><![CDATA[local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")
local DataStoreService = game:GetService("DataStoreService")
local AnalyticsService = game:GetService("AnalyticsService")

local BoostManager = require(script.Parent.BoostManager)

local STORE_DATASTORE_NAME = "StoreService_PlayerData_V1"
local MAX_RETRIES = 5
local RETRY_DELAY = 2

local defaultStoreData = {
	Currency = 0,
	ActiveBoosts = {},
	OwnedPasses = {},
	ProcessedReceipts = {},
}

-- Replace placeholder IDs with the experiences actual product and gamepass ids.
local DEV_PRODUCTS = {
	[111111] = {
		name = "Currency Pack",
		currencyAmount = 5000,
		currencyCode = "DATA",
	},
	[111112] = {
		name = "5 Min Boost",
		boostName = "+5 Min Boost",
		boostDuration = 5 * 60,
	},
	[111113] = {
		name = "1 Hour Boost",
		boostName = "+1 Hour Boost",
		boostDuration = 60 * 60,
	},
}

local GAMEPASSES = {
	[222221] = {
		name = "x2 Data",
		attribute = "HasX2DataPass",
	},
	[222222] = {
		name = "Faster Auto",
		attribute = "HasFasterAutoPass",
	},
}

local playerStoreCache: { [string]: typeof(defaultStoreData) } = {}
local storeDataStore = DataStoreService:GetDataStore(STORE_DATASTORE_NAME)

local function deepCopy<T>(source: { [any]: T }): { [any]: T }
	local target = {}
	for key, value in source do
		if typeof(value) == "table" then
			target[key] = deepCopy(value)
		else
			target[key] = value
		end
	end
	return target
end

local function sanitizeBoosts(boosts: any): { [string]: number }
	local sanitized: { [string]: number } = {}
	if typeof(boosts) ~= "table" then
		return sanitized
	end

	local now = os.time()
	for boostName, expiration in boosts do
		if typeof(boostName) == "string" and typeof(expiration) == "number" and expiration > now then
			sanitized[boostName] = expiration
		end
	end

	return sanitized
end

local function sanitizePasses(passes: any): { [string]: boolean }
	local sanitized: { [string]: boolean } = {}
	if typeof(passes) ~= "table" then
		return sanitized
	end

	for passId, owned in pairs(passes) do
		if typeof(passId) == "string" and typeof(owned) == "boolean" then
			sanitized[passId] = owned
		elseif typeof(passId) == "number" and typeof(owned) == "boolean" then
			sanitized[tostring(passId)] = owned
		end
	end

	return sanitized
end

local function sanitizeProcessed(receipts: any): { [string]: boolean }
	local sanitized: { [string]: boolean } = {}
	if typeof(receipts) ~= "table" then
		return sanitized
	end

	for receiptId, processed in pairs(receipts) do
		if typeof(receiptId) == "string" and processed == true then
			sanitized[receiptId] = true
		end
	end

	return sanitized
end

local function sanitizeStoreData(payload: any)
	local sanitized = deepCopy(defaultStoreData)

	if typeof(payload) ~= "table" then
		return sanitized
	end

	if typeof(payload.Currency) == "number" then
		sanitized.Currency = math.max(0, payload.Currency)
	end

	sanitized.ActiveBoosts = sanitizeBoosts(payload.ActiveBoosts)
	sanitized.OwnedPasses = sanitizePasses(payload.OwnedPasses)
	sanitized.ProcessedReceipts = sanitizeProcessed(payload.ProcessedReceipts)

	return sanitized
end

local function getPlayerKey(player: Player): string
	return tostring(player.UserId)
end

local function loadStoreData(userId: string)
	local attempts = 0
	repeat
		attempts += 1
		local success, result = pcall(function()
			return storeDataStore:GetAsync(userId)
		end)

		if success then
			return sanitizeStoreData(result)
		end

		warn("[StoreService] GetAsync failed for", userId, "attempt", attempts)
		if attempts < MAX_RETRIES then
			task.wait(RETRY_DELAY)
		end
	until attempts >= MAX_RETRIES

	return deepCopy(defaultStoreData)
end

local function saveStoreData(userId: string, payload)
	local attempts = 0
	repeat
		attempts += 1
		local success, err = pcall(function()
			storeDataStore:SetAsync(userId, payload)
		end)

		if success then
			return true
		end

		warn("[StoreService] SetAsync failed for", userId, err)
		if attempts < MAX_RETRIES then
			task.wait(RETRY_DELAY)
		end
	until attempts >= MAX_RETRIES

	return false
end

local function getPlayerStoreData(player: Player)
	local userId = getPlayerKey(player)
	if playerStoreCache[userId] then
		return playerStoreCache[userId]
	end

	local data = loadStoreData(userId)
	playerStoreCache[userId] = data
	return data
end

local function savePlayerStoreData(player: Player)
	local userId = getPlayerKey(player)
	local cached = playerStoreCache[userId]
	if not cached then
		return false
	end

	return saveStoreData(userId, cached)
end

local function releasePlayerStoreData(player: Player)
	playerStoreCache[getPlayerKey(player)] = nil
end

local function logIapGrant(player: Player, currencyCode: string, amount: number, source: string)
	if amount <= 0 then
		return
	end

	task.spawn(function()
		local ok, err = pcall(function()
			AnalyticsService:FireInGameEconomyEvent(player, Enum.AnalyticsEconomyTransactionType.IAP, currencyCode, amount, source or "Store", nil)
		end)

		if not ok then
			warn("[StoreService] Failed to log economy event:", err)
		end
	end)
end

local function logStorePurchase(player: Player, productType: string, productId: number, itemName: string?)
	local platform = player:GetAttribute("StorePlatform") or "Unknown"
	local data = {
		ItemName = itemName or "",
		ProductType = productType or "",
		ProductId = productId or 0,
		Platform = platform,
		UserId = player.UserId,
	}

	local ok, err = pcall(function()
		AnalyticsService:LogCustomEvent(player, "StorePurchaseCompleted", 1, data)
	end)

	if not ok then
		warn("[StoreService] Failed to log purchase analytics:", err)
	end
end

local function addCurrency(player: Player, dataTable, amount: number, source: string?)
	if amount <= 0 then
		return
	end

	dataTable.Currency = math.max(0, (dataTable.Currency or 0) + amount)
	logIapGrant(player, "DATA", amount, source or "DevProduct")
end

local function addBoost(player: Player, dataTable, boostName: string, duration: number)
	if duration <= 0 then
		return
	end

	local now = os.time()
	local existing = dataTable.ActiveBoosts[boostName]
	local startTime = math.max(now, typeof(existing) == "number" and existing or now)
	local expiration = startTime + duration
	dataTable.ActiveBoosts[boostName] = expiration
	player:SetAttribute(boostName .. "Expires", expiration)

	BoostManager.AddBoostDuration(player, boostName, duration)
end

local function markPassOwned(player: Player, dataTable, passId: number, config)
	local key = tostring(passId)
	if dataTable.OwnedPasses[key] then
		if config and config.attribute then
			player:SetAttribute(config.attribute, true)
		end
		return
	end

	dataTable.OwnedPasses[key] = true
	if config and config.attribute then
		player:SetAttribute(config.attribute, true)
	end
end

local function ensureStoredBoostAttributes(player: Player, dataTable)
	local now = os.time()
	for boostName, expiration in pairs(dataTable.ActiveBoosts) do
		if typeof(expiration) ~= "number" or expiration <= now then
			dataTable.ActiveBoosts[boostName] = nil
			player:SetAttribute(boostName .. "Expires", nil)
		else
			player:SetAttribute(boostName .. "Expires", expiration)
		end
	end
end

local function ensureStoredPassAttributes(player: Player, dataTable)
	for _, config in pairs(GAMEPASSES) do
		if config.attribute then
			player:SetAttribute(config.attribute, false)
		end
	end

	for passId, owned in pairs(dataTable.OwnedPasses) do
		if owned then
			local numericId = tonumber(passId)
			if numericId then
				local config = GAMEPASSES[numericId]
				if config and config.attribute then
					player:SetAttribute(config.attribute, true)
				end
			end
		end
	end
end

local function grantDevProduct(player: Player, productId: number, receiptId: string)
	local config = DEV_PRODUCTS[productId]
	if not config then
		warn("[StoreService] Unknown developer product:", productId)
		return true
	end

	local dataTable = getPlayerStoreData(player)

	if dataTable.ProcessedReceipts[receiptId] then
		return true
	end

	if config.currencyAmount then
		addCurrency(player, dataTable, config.currencyAmount, config.name)
	end

	if config.boostName and config.boostDuration then
		addBoost(player, dataTable, config.boostName, config.boostDuration)
	end

	dataTable.ProcessedReceipts[receiptId] = true

	local saved = savePlayerStoreData(player)
	if not saved then
		warn("[StoreService] Failed to persist data for receipt", receiptId)
	else
		logStorePurchase(player, "DevProduct", productId, config.name)
	end

	return saved
end

local function checkGamepassOwnership(player: Player, passId: number, config)
	local dataTable = getPlayerStoreData(player)
	local key = tostring(passId)
	if dataTable.OwnedPasses[key] then
		if config and config.attribute then
			player:SetAttribute(config.attribute, true)
		end
		return
	end

	local success, owns = pcall(function()
		return MarketplaceService:UserOwnsGamePassAsync(player.UserId, passId)
	end)

	if not success then
		warn("[StoreService] Gamepass ownership check failed:", passId)
		return
	end

	if owns then
		markPassOwned(player, dataTable, passId, config)
		savePlayerStoreData(player)
	end
end

local function onPlayerAdded(player: Player)
	local dataTable = getPlayerStoreData(player)
	ensureStoredBoostAttributes(player, dataTable)
	ensureStoredPassAttributes(player, dataTable)

	for passId, config in pairs(GAMEPASSES) do
		checkGamepassOwnership(player, passId, config)
	end
end

local function onPlayerRemoving(player: Player)
	savePlayerStoreData(player)
	releasePlayerStoreData(player)
end

Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)

MarketplaceService.PromptGamePassPurchaseFinished:Connect(function(player, passId, wasPurchased)
	if not wasPurchased then
		return
	end

	local config = GAMEPASSES[passId]
	if not config then
		return
	end

	local dataTable = getPlayerStoreData(player)
	markPassOwned(player, dataTable, passId, config)
	if savePlayerStoreData(player) then
		logStorePurchase(player, "Gamepass", passId, config.name)
	end
end)

MarketplaceService.ProcessReceipt = function(receiptInfo)
	local player = Players:GetPlayerByUserId(receiptInfo.PlayerId)
	if not player then
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end

	local receiptId = tostring(receiptInfo.PurchaseId)
	local dataTable = getPlayerStoreData(player)
	if dataTable.ProcessedReceipts[receiptId] then
		return Enum.ProductPurchaseDecision.PurchaseGranted
	end

	local granted = grantDevProduct(player, receiptInfo.ProductId, receiptId)
	if not granted then
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end

	return Enum.ProductPurchaseDecision.PurchaseGranted
end

game:BindToClose(function()
	for _, player in ipairs(Players:GetPlayers()) do
		onPlayerRemoving(player)
	end
end)
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="23">
        <Properties>
          <string name="Name">StoreService</string>
          <token name="RunContext">0</token>
          <string name="Source"></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="24">
        <Properties>
          <string name="Name">UpgradeService</string>
          <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local PlayerDataService = require(script.Parent.PlayerDataService)
local UpgradeConfig = require(ReplicatedStorage.Shared.UpgradeConfig)

local UpgradeService = {}

local function getUpgradeDefinition(upgradeId)
	if typeof(upgradeId) ~= "string" then
		return nil
	end

	return UpgradeConfig.GetUpgradeById(upgradeId)
end

local function ensurePlayerState(player)
	local state = PlayerDataService.Get(player)
	if typeof(state) ~= "table" then
		return nil
	end

	if typeof(state.upgrades) ~= "table" then
		state.upgrades = {}
	end

	if typeof(state.data) ~= "number" then
		state.data = 0
	end

	return state
end

local function evaluatePurchase(state, upgradeId)
	local definition = getUpgradeDefinition(upgradeId)
	if not definition then
		return false, nil, 0, "locked"
	end

	local upgrades = state.upgrades
	local currentLevel = UpgradeConfig.GetLevel(upgrades, upgradeId)

	if UpgradeConfig.IsMaxed(upgrades, upgradeId) then
		return false, nil, currentLevel, "max"
	end

	if not UpgradeConfig.MeetsRequirements(upgrades, upgradeId) then
		return false, nil, currentLevel, "locked"
	end

	local cost = UpgradeConfig.GetCost(upgradeId, currentLevel)
	if typeof(cost) ~= "number" then
		return false, nil, currentLevel, "locked"
	end

	if (state.data or 0) < cost then
		return false, cost, currentLevel, "poor"
	end

	return true, cost, currentLevel, nil
end

local function planPurchase(state, upgradeId, desiredQuantity)
	local success, _, currentLevel, reason = evaluatePurchase(state, upgradeId)
	if not success then
		return 0, state.data or 0, currentLevel, reason
	end

	local definition = getUpgradeDefinition(upgradeId)
	if not definition then
		return 0, state.data or 0, currentLevel, "locked"
	end

	local remainingData = state.data or 0
	local purchases = 0
	local maxLevel = definition.maxLevel

	while currentLevel < maxLevel do
		if desiredQuantity and purchases >= desiredQuantity then
			break
		end

		local cost = UpgradeConfig.GetCost(upgradeId, currentLevel)
		if typeof(cost) ~= "number" or remainingData < cost then
			break
		end

		remainingData -= cost
		currentLevel += 1
		purchases += 1
	end

	if purchases <= 0 then
		return 0, state.data or 0, currentLevel, "poor"
	end

	return purchases, remainingData, currentLevel, nil
end

local function executePurchase(player, upgradeId, desiredQuantity)
	local state = ensurePlayerState(player)
	if not state then
		return false, "locked", 0
	end

	local quantity, remainingData, resultingLevel, reason = planPurchase(state, upgradeId, desiredQuantity)
	if quantity <= 0 then
		return false, reason or "locked", 0
	end

	state.data = remainingData
	state.upgrades[upgradeId] = resultingLevel

	PlayerDataService.Set(player, state)

	return true, quantity
end

function UpgradeService.CanBuy(player, upgradeId)
	local state = ensurePlayerState(player)
	if not state then
		return false, "locked"
	end

	local success, _, _, reason = evaluatePurchase(state, upgradeId)
	return success, reason
end

function UpgradeService.Buy(player, upgradeId)
	local success, reasonOrQuantity = executePurchase(player, upgradeId, 1)
	if not success then
		return false, reasonOrQuantity
	end

	return true, reasonOrQuantity
end

function UpgradeService.BuyMax(player, upgradeId)
	local success, purchased = executePurchase(player, upgradeId, nil)
	return success, purchased
end

return UpgradeService
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="SoundService" referent="25">
    <Properties>
      <string name="Name">SoundService</string>
      <bool name="RespectFilteringEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="StarterPlayer" referent="26">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="27">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="Folder" referent="28">
        <Properties>
          <string name="Name">Client</string>
        </Properties>
        <Item class="ModuleScript" referent="29">
          <Properties>
            <string name="Name">BoostUIController</string>
            <string name="Source"><![CDATA[local BoostUIController = {}
local initialized = false
local moduleApi

function BoostUIController.Init(context)
	if initialized then
		return moduleApi
	end

	local ui = context.ui or {}
	local topBar = ui.topBar
	local safeFind = context.safeFind
	local boostsUpdatedEvent = context.remotes and context.remotes.boostsUpdatedEvent

	if not topBar then
		return nil
	end

	local function createBoostLabel(parent)
		local label = Instance.new("TextLabel")
		label.Name = "BoostLabel"
		label.AnchorPoint = Vector2.new(1, 0)
		label.Position = UDim2.new(1, -16, 0, 8)
		label.Size = UDim2.new(0, 140, 0, 24)
		label.BackgroundTransparency = 1
		label.TextColor3 = Color3.new(1, 1, 1)
		label.Text = ""
		label.Font = Enum.Font.GothamBold
		label.TextSize = 18
		label.TextXAlignment = Enum.TextXAlignment.Right
		label.TextYAlignment = Enum.TextYAlignment.Center
		label.Visible = false
		label.Parent = parent
		return label
	end

	local function formatBoostMultiplier(multiplier)
		if math.abs(multiplier - math.floor(multiplier + 0.001)) <= 0.01 then
			return string.format("BOOST x%d", math.floor(multiplier + 0.5))
		end
		return string.format("BOOST x%.2f", multiplier)
	end

	local boostLabel = safeFind(topBar, "BoostLabel")
	if not boostLabel then
		boostLabel = createBoostLabel(topBar)
	end

	local function updateBoostLabel(multiplier)
		if not boostLabel then
			return
		end

		if typeof(multiplier) ~= "number" or multiplier <= 1 then
			boostLabel.Visible = false
			return
		end

		boostLabel.Text = formatBoostMultiplier(multiplier)
		boostLabel.Visible = true
	end

	updateBoostLabel(1)

	if boostsUpdatedEvent then
		boostsUpdatedEvent.OnClientEvent:Connect(function(_, multiplier)
			updateBoostLabel(typeof(multiplier) == "number" and multiplier or 1)
		end)
	else
		updateBoostLabel(1)
	end

	moduleApi = {
		UpdateBoostLabel = updateBoostLabel,
	}
	initialized = true

	return moduleApi
end

return BoostUIController
]]></string>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="30">
          <Properties>
            <string name="Name">DebugWatcher</string>
            <string name="Source"><![CDATA[local DEBUG_ENABLED = false

if not DEBUG_ENABLED then
	return
end

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer or Players.PlayerAdded:Wait()
if not player then
	warn("[DEBUG][WARN] LocalPlayer not available")
	return
end

local function log(prefix, message)
	print(string.format("[DEBUG][%s] %s", prefix, message))
end

local function warnLog(message)
	warn(string.format("[DEBUG][WARN] %s", message))
end

local function getRemotes()
	local remotesFolder = ReplicatedStorage:FindFirstChild("Remotes")
	if not remotesFolder then
		return nil
	end
	return remotesFolder
end

local playerGui = player:WaitForChild("PlayerGui", 5)
if not playerGui then
	warnLog("PlayerGui missing")
	return
end

local serverDataStagnantCount = 0
local lastServerDataValue = nil
local uiDataText = nil
local uiStagnantCount = 0
local missingTerminalWarned = false
local missingRequestSyncWarned = false
local missingUIWarned = false

local function sampleServerState()
	local remotes = getRemotes()
	if not remotes then
		if not missingRequestSyncWarned then
			warnLog("Remotes folder missing; cannot RequestSync")
			missingRequestSyncWarned = true
		end
		return
	end

	local requestSync = remotes:FindFirstChild("RequestSync")
	if not requestSync or not requestSync:IsA("RemoteFunction") then
		if not missingRequestSyncWarned then
			warnLog("RequestSync remote missing or invalid")
			missingRequestSyncWarned = true
		end
		return
	end

	local ok, state = pcall(function()
		return requestSync:InvokeServer()
	end)

	if not ok then
		warnLog("RequestSync failed: " .. tostring(state))
		return
	end

	if typeof(state) ~= "table" then
		warnLog("RequestSync returned non-table state")
		return
	end

	local dataValue = typeof(state.data) == "number" and state.data or 0
	local dpsValue = typeof(state.dps) == "number" and state.dps or 0
	local prestigeValue = typeof(state.prestige) == "number" and state.prestige or 0
	local corePowerValue = typeof(state.corePower) == "number" and state.corePower or 0

	log("SERVER", string.format("Data=%.3f DPS=%.3f Prestige=%d Core=%d", dataValue, dpsValue, prestigeValue, corePowerValue))

	if dpsValue <= 0 then
		warnLog("DPS is zero or negative")
	end

	if lastServerDataValue ~= nil and dataValue <= lastServerDataValue then
		serverDataStagnantCount += 1
		if serverDataStagnantCount >= 5 then
			warnLog("Server data not increasing")
			serverDataStagnantCount = 0
		end
	else
		serverDataStagnantCount = 0
	end

	lastServerDataValue = dataValue
end

local function resolveUI()
	local terminal = playerGui:FindFirstChild("TerminalUI")
	if not terminal then
		if not missingTerminalWarned then
			warnLog("TerminalUI missing from PlayerGui")
			missingTerminalWarned = true
		end
		return nil
	end

	local root = terminal:FindFirstChild("Root")
	local safeArea = root and root:FindFirstChild("SafeArea")
	local topBar = safeArea and safeArea:FindFirstChild("TopBar")
	local main = safeArea and safeArea:FindFirstChild("Main")
	local rightPanel = main and main:FindFirstChild("RightPanel")
	local statsBox = rightPanel and rightPanel:FindFirstChild("StatsBox")

	if not (topBar and statsBox) then
		if not missingUIWarned then
			warnLog("TopBar or StatsBox missing")
			missingUIWarned = true
		end
		return nil
	end

	local dataValueLabel = topBar:FindFirstChild("DataValue")
	local stat1 = statsBox:FindFirstChild("Stat1")
	local stat2 = statsBox:FindFirstChild("Stat2")
	local stat3 = statsBox:FindFirstChild("Stat3")

	if not (dataValueLabel and stat1 and stat2 and stat3) then
		if not missingUIWarned then
			warnLog("Stat labels missing")
			missingUIWarned = true
		end
		return nil
	end

	return {
		dataValue = dataValueLabel,
		stat1 = stat1,
		stat2 = stat2,
		stat3 = stat3,
	}
end

local observedUI = resolveUI()

task.spawn(function()
	while task.wait(1) do
		local ok, err = pcall(sampleServerState)
		if not ok then
			warnLog("Server sampler error: " .. tostring(err))
		end
	end
end)

task.spawn(function()
	while task.wait(0.5) do
		if not observedUI then
			observedUI = resolveUI()
		end

		if observedUI and observedUI.dataValue then
			local text = observedUI.dataValue.Text
			log("UI", string.format("DataValue=%s", tostring(text)))
			if uiDataText and uiDataText == text then
				uiStagnantCount += 1
				if uiStagnantCount >= 6 then
					warnLog("DataValue text not updating")
					uiStagnantCount = 0
				end
			else
				uiStagnantCount = 0
			end
			uiDataText = text
		end

		if observedUI and not observedUI.dataValue then
			observedUI = nil
		end
	end
end)
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="31">
          <Properties>
            <string name="Name">LoadingInitializer</string>
            <string name="Source"><![CDATA[local LoadingInitializer = {}

function LoadingInitializer.Init()
	local success, errorMessage = pcall(function()
	local Players = game:GetService("Players")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local RunService = game:GetService("RunService")
	local TweenService = game:GetService("TweenService")
	local MarketplaceService = game:GetService("MarketplaceService")
	local UserInputService = game:GetService("UserInputService")
	local TerminalUIBinder = require(script.Parent:WaitForChild("TerminalUIBinder"))
	local ToastController = require(script.Parent:WaitForChild("ToastController"))
	local StoreUIController = require(script.Parent:WaitForChild("StoreUIController"))
	local BoostUIController = require(script.Parent:WaitForChild("BoostUIController"))
	local StarterGui = game:GetService("StarterGui")

	local player = Players.LocalPlayer or Players.PlayerAdded:Wait()
	if not player then
		warn("[TerminalClient] LocalPlayer missing")
		return
	end

	local clientReadyFlag = false
	local readyCallbacks = {}

	local function signalClientReady()
		if clientReadyFlag then
			return
		end

		clientReadyFlag = true

		if player then
			player:SetAttribute("ClientReady", true)
		end

		for _, callback in ipairs(readyCallbacks) do
			task.defer(callback)
		end
		table.clear(readyCallbacks)
	end

	local function safeFind(parent, name)
		if not parent then
			return nil
		end
		return parent:FindFirstChild(name)
	end
	local WAIT_TIMEOUT = 5
	local LOADING_UI_DISPLAY_ORDER = 999999
	local READY_TIMEOUT = 15
	local LONG_PRESS_THRESHOLD = 0.4
	local MIN_BUTTON_HEIGHT = 44
	local PENDING_MAX_TIMEOUT = 2
	local BUY_MODE_SINGLE = "single"
	local BUY_MODE_MAX = "max"
	local isTouchOnlyDevice = UserInputService.TouchEnabled and not UserInputService.MouseEnabled

	local function waitForChildWithTimeout(parent, childName)
		if not parent then
			return nil
		end

		local ok, child = pcall(function()
			return parent:WaitForChild(childName, WAIT_TIMEOUT)
		end)

		if ok then
			return child
		end

		return nil
	end

	local function cloneLoadingUi(parent)
		if not parent or not StarterGui then
			return nil
		end

		local template = StarterGui:FindFirstChild("LoadingUI")
		if not template then
			return nil
		end

		local clone = template:Clone()
		if clone:IsA("LayerCollector") then
			clone.ResetOnSpawn = false
		end
		clone.Parent = parent
		return clone
	end

	local function ensureLoadingUiProperties(ui)
		if not ui then
			return
		end

		if ui:IsA("LayerCollector") then
			ui.DisplayOrder = LOADING_UI_DISPLAY_ORDER
			ui.Enabled = true
			ui.ResetOnSpawn = false
		elseif ui:IsA("GuiObject") then
			ui.Visible = true
			ui.ZIndex = math.max(ui.ZIndex, LOADING_UI_DISPLAY_ORDER)
		end

		local background = safeFind(ui, "Background")
		if background and background:IsA("GuiObject") then
			background.Visible = true
		end
	end

	local playerGui = player:WaitForChild("PlayerGui", 5)
	if not playerGui then
		warn("[TerminalClient] PlayerGui missing")
		return
	end

	local loadingUi = playerGui:FindFirstChild("LoadingUI")
	if not loadingUi then
		loadingUi = cloneLoadingUi(playerGui)
	end
	if not loadingUi then
		loadingUi = waitForChildWithTimeout(playerGui, "LoadingUI")
	end
	if loadingUi then
		ensureLoadingUiProperties(loadingUi)
	end

	local remotesFolder = waitForChildWithTimeout(ReplicatedStorage, "Remotes") or safeFind(ReplicatedStorage, "Remotes")
	local loadingProgressEvent = remotesFolder and safeFind(remotesFolder, "LoadingProgress")
	local storeAnalyticsEvent = remotesFolder and safeFind(remotesFolder, "StoreAnalyticsEvent")
	local boostsUpdatedEvent = remotesFolder and safeFind(remotesFolder, "BoostsUpdated")
	local offlinePreviewEvent = remotesFolder and safeFind(remotesFolder, "OfflineEarningsPreview")

	local loadingBackground = loadingUi and safeFind(loadingUi, "Background")
	local loadingStatus = loadingUi and safeFind(loadingUi, "Status") or (loadingBackground and safeFind(loadingBackground, "Status"))
	local loadingBarBack = (loadingBackground and safeFind(loadingBackground, "BarBack")) or (loadingUi and safeFind(loadingUi, "BarBack"))
	local loadingBarFill = loadingBarBack and safeFind(loadingBarBack, "BarFill")
	local loadingBarFillBaseSize = loadingBarFill and loadingBarFill.Size or UDim2.new(1, 0, 1, 0)

	local handleLoadingProgress
	local pendingLoadingUpdates = {}
	local loadingBarTween
	local loadingUiFadeTween
	local loadingUiFinalized = false
	local loadingInputLocked = false
	local previousModalState = UserInputService.ModalEnabled
	local readyFired = false
	local serverReady = false
	local localReady = false
	local latestServerProgress = 0
	local failsafeWarned = false

	local function setBarFillInstant(scale)
		if loadingBarFill and loadingBarFill:IsA("GuiObject") then
			loadingBarFill.Size = UDim2.new(
				math.clamp(scale, 0, 1),
				loadingBarFillBaseSize.X.Offset,
				loadingBarFillBaseSize.Y.Scale,
				loadingBarFillBaseSize.Y.Offset
			)
		end
	end

	local function lockLoadingInput()
		if loadingInputLocked then
			return
		end

		loadingInputLocked = true
		previousModalState = UserInputService.ModalEnabled
		UserInputService.ModalEnabled = true
	end

	local function unlockLoadingInput()
		if not loadingInputLocked then
			return
		end

		loadingInputLocked = false
		UserInputService.ModalEnabled = previousModalState
	end

	if loadingUi then
		lockLoadingInput()
	end

	if loadingBarFill then
		setBarFillInstant(0)
	end

	local function destroyLoadingUi()
		if loadingUi then
			if loadingUi:IsA("LayerCollector") then
				loadingUi.Enabled = false
			elseif loadingUi:IsA("GuiObject") then
				loadingUi.Visible = false
			end
			loadingUi:Destroy()
			loadingUi = nil
		end

		loadingBackground = nil
		loadingStatus = nil
		loadingBarFill = nil
		loadingBarBack = nil
		table.clear(pendingLoadingUpdates)

		unlockLoadingInput()

		signalClientReady()
	end

	local function finalizeLoadingUi()
		if loadingUiFinalized then
			return
		end

		loadingUiFinalized = true

		if loadingBarTween then
			loadingBarTween:Cancel()
			loadingBarTween = nil
		end

		if loadingUiFadeTween then
			loadingUiFadeTween:Cancel()
			loadingUiFadeTween = nil
		end

		local fadeTarget = (loadingBackground and loadingBackground:IsA("GuiObject")) and loadingBackground or loadingUi
		if fadeTarget and fadeTarget:IsA("GuiObject") then
			if loadingStatus and loadingStatus:IsA("TextLabel") then
				TweenService:Create(
					loadingStatus,
					TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
					{ TextTransparency = 1 }
				):Play()
			end

			if loadingBarFill and loadingBarFill:IsA("GuiObject") then
				TweenService:Create(
					loadingBarFill,
					TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
					{ BackgroundTransparency = 1 }
				):Play()
			end

			loadingUiFadeTween = TweenService:Create(
				fadeTarget,
				TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
				{ BackgroundTransparency = 1 }
			)
			loadingUiFadeTween.Completed:Connect(function()
				loadingUiFadeTween = nil
				destroyLoadingUi()
			end)
			loadingUiFadeTween:Play()
		else
			destroyLoadingUi()
		end
	end

	local function applyLoadingProgress(statusText, progress)
		if loadingUiFinalized then
			return
		end

		lockLoadingInput()

		if typeof(statusText) == "string" and loadingStatus and loadingStatus:IsA("TextLabel") then
			loadingStatus.Text = statusText
		end

		local numericProgress = tonumber(progress)
		if numericProgress then
			numericProgress = math.clamp(numericProgress, 0, 1)

			if loadingBarFill and loadingBarFill:IsA("GuiObject") then
				if loadingBarTween then
					loadingBarTween:Cancel()
				end

				local tween = TweenService:Create(
					loadingBarFill,
					TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
					{
						Size = UDim2.new(
							numericProgress,
							loadingBarFillBaseSize.X.Offset,
							loadingBarFillBaseSize.Y.Scale,
							loadingBarFillBaseSize.Y.Offset
						),
					}
				)
				loadingBarTween = tween
				tween.Completed:Connect(function()
					if loadingBarTween == tween then
						loadingBarTween = nil
					end
				end)
				tween:Play()
			end

		end
	end

	local function setLoadingStep(stepName, progress)
		applyLoadingProgress(stepName, progress)
	end

	local function setLoadingStep(stepName, progress)
		applyLoadingProgress(stepName, progress)
	end

	local function trySetReady(force)
		if readyFired then
			return
		end

		if not force then
			if not (serverReady and localReady) then
				return
			end
		end

		readyFired = true

		setLoadingStep("Finalizing", 1)

		if not loadingUiFinalized then
			finalizeLoadingUi()
		else
			unlockLoadingInput()
			if not loadingUi then
				signalClientReady()
			end
		end
	end

	handleLoadingProgress = function(statusText, progress)
		if not loadingUi then
			table.insert(pendingLoadingUpdates, { statusText, progress })
			if typeof(progress) == "number" and progress >= 1 then
				finalizeLoadingUi()
			end
			return
		end

		applyLoadingProgress(statusText, progress)
	end

	local function flushPendingLoadingProgress()
		if not loadingUi or #pendingLoadingUpdates == 0 then
			return
		end

		local queued = table.clone(pendingLoadingUpdates)
		table.clear(pendingLoadingUpdates)
		for _, payload in ipairs(queued) do
			applyLoadingProgress(payload[1], payload[2])
		end
	end

	if loadingUi then
		handleLoadingProgress("Preparing UI", 0)
		flushPendingLoadingProgress()
	end

	if remotesFolder then
		setLoadingStep("Connecting Remotes", 0.05)
	end

	local serverStepMap = {
		["Loading data"] = { name = "Loading Player Data", progress = 0.25 },
		["Applying offline earnings"] = { name = "Applying Offline Earnings", progress = 0.5 },
		["Syncing boosts"] = { name = "Syncing Boosts", progress = 0.75 },
		["Finalizing"] = { name = "Finalizing", progress = 1 },
	}

	if loadingProgressEvent then
		loadingProgressEvent.OnClientEvent:Connect(function(message, progress)
			local mapped = serverStepMap[message]
			local resolvedProgress = progress
			if mapped then
				resolvedProgress = mapped.progress
				setLoadingStep(mapped.name, resolvedProgress)
			else
				handleLoadingProgress(message, progress)
			end

			if typeof(resolvedProgress) == "number" then
				local clamped = math.clamp(resolvedProgress, 0, 1)
				if clamped > latestServerProgress then
					latestServerProgress = clamped
				end
				if clamped >= 1 then
					serverReady = true
					trySetReady(false)
				end
			end
		end)
	end

	task.delay(READY_TIMEOUT, function()
		if readyFired then
			return
		end

		if not failsafeWarned then
			failsafeWarned = true
			warn("[TerminalClient] Loading timed out, forcing ready")
		end

		trySetReady(true)
	end)

	local sharedFolder = ReplicatedStorage:WaitForChild("Shared")
	local NumberFormatter = require(sharedFolder:WaitForChild("NumberFormatter"))

	local context = {
		player = player,
		playerGui = playerGui,
		safeFind = safeFind,
		waitForChildWithTimeout = waitForChildWithTimeout,
		TweenService = TweenService,
		MarketplaceService = MarketplaceService,
		UserInputService = UserInputService,
		NumberFormatter = NumberFormatter,
		IsClientReady = function()
			return clientReadyFlag
		end,
		OnClientReady = function(callback)
			if clientReadyFlag then
				task.defer(callback)
			else
				table.insert(readyCallbacks, callback)
			end
		end,
		remotes = {
			storeAnalyticsEvent = storeAnalyticsEvent,
			boostsUpdatedEvent = boostsUpdatedEvent,
			offlinePreviewEvent = offlinePreviewEvent,
		},
	}

	if not TerminalUIBinder.Init(context) then
		return
	end

	local ui = context.ui
	local root = ui.root
	local safeArea = ui.safeArea
	local topBar = ui.topBar
	local main = ui.main
	local columns = ui.columns
	local cpuCards = ui.cpuCards
	local ramCards = ui.ramCards
	local stoCards = ui.stoCards
	local statsBox = ui.statsBox
	local prestigeBox = ui.prestigeBox
	local toastArea = ui.toastArea

	local dataValueLabel = safeFind(topBar, "DataValue")
	if not dataValueLabel then
		warn("[TerminalClient] DataValue missing")
		return
	end

	local statsLabels = {
		safeFind(statsBox, "Stat1"),
		safeFind(statsBox, "Stat2"),
		safeFind(statsBox, "Stat3"),
	}

	local toastController = ToastController.Init(context)
	local storeController = StoreUIController.Init(context)
	local boostController = BoostUIController.Init(context)
	local showToast = toastController and toastController.ShowToast or function() end

	if storeController then
		if storeController.RefreshGamepassOwnership then
			storeController.RefreshGamepassOwnership()
		end
		setLoadingStep("Checking Store Ownership", 0.8)
	end

	local prestigeButton = safeFind(prestigeBox, "PrestigeButton")
	local prestigeOverlay = safeFind(prestigeBox, "PrestigeLockedOverlay")

	local template = playerGui:FindFirstChild("UpgradeCardTemplate")
	if not template then
		warn("[TerminalClient] UpgradeCardTemplate missing")
		return
	end

	if template:IsA("GuiObject") then
		template.Visible = false
	end

	if not remotesFolder then
		warn("[TerminalClient] Remotes folder missing")
		return
	end

	local requestSync = safeFind(remotesFolder, "RequestSync")
	local buyUpgradeEvent = safeFind(remotesFolder, "RequestBuyUpgrade")
	local prestigeEvent = safeFind(remotesFolder, "RequestPrestige")
	if not (requestSync and buyUpgradeEvent and prestigeEvent) then
		warn("[TerminalClient] Required remotes missing")
		return
	end

	local UpgradeConfig = require(sharedFolder:WaitForChild("UpgradeConfig"))

	local function formatIntegerWithCommas(value)
		local str = tostring(value)
		while true do
			local formatted, k = str:gsub("^(-?%d+)(%d%d%d)", "%1,%2")
			str = formatted
			if k == 0 then
				break
			end
		end
		return str
	end

	local function formatDataValueText(value)
		local n = typeof(value) == "number" and value or 0
		if n < 0 then
			n = 0
		end

		if n < 100_000 then
			local integerPart = math.floor(n)
			local fractionalPart = n - integerPart

			local formatted = formatIntegerWithCommas(integerPart)
			if fractionalPart > 0 then
				local fractionalText = string.sub(string.format("%.3f", fractionalPart), 2)
				fractionalText = fractionalText:gsub("0+$", "")
				if fractionalText ~= "." then
					formatted ..= fractionalText
				end
			end

			return formatted
		end

		local suffix
		local divisor

		if n < 1_000_000 then
			suffix = "K"
			divisor = 1_000
		elseif n < 1_000_000_000 then
			suffix = "M"
			divisor = 1_000_000
		else
			suffix = "B"
			divisor = 1_000_000_000
		end

		local scaled = math.floor((n / divisor) * 100) / 100
		return string.format("%.2f%s", scaled, suffix)
	end

	local playerState = {
		data = 0,
		upgrades = {},
		prestige = 0,
		corePower = 0,
	}
	local cachedState = nil
	local uiUpdateStarted = false
	local displayedData = nil

	local upgradeCards = {}
	local syncLoopStarted = false
	local syncLoopWarningIssued = false

	local function getUpgradeLevel(upgradeId)
		local level = playerState.upgrades[upgradeId]
		if typeof(level) ~= "number" then
			return 0
		end
		return math.max(level, 0)
	end

	local pendingBuyMaxQueue = {}

	local function queueBuyMaxFeedback(upgradeId)
		table.insert(pendingBuyMaxQueue, {
			id = upgradeId,
			startLevel = getUpgradeLevel(upgradeId),
			timestamp = os.clock(),
		})
	end

	local function processPendingBuyMaxFeedback()
		if #pendingBuyMaxQueue == 0 then
			return
		end

		local remaining = {}
		for _, pending in ipairs(pendingBuyMaxQueue) do
			local newLevel = getUpgradeLevel(pending.id)
			local delta = math.max(newLevel - (pending.startLevel or 0), 0)

			if delta > 0 then
				local cardData = upgradeCards[pending.id]
				if showToast then
					if cardData and cardData.definition then
						local message = string.format(
							"Bought %d %s of %s",
							delta,
							delta == 1 and "level" or "levels",
							cardData.definition.name
						)
						showToast(message)
					else
						showToast(string.format("Bought %d upgrades", delta))
					end
				end

				if delta >= 10 then
					flashMaxBadge(cardData)
				end
			else
				if os.clock() - pending.timestamp < PENDING_MAX_TIMEOUT then
					table.insert(remaining, pending)
				else
					playErrorFeedback(upgradeCards[pending.id])
				end
			end
		end

		pendingBuyMaxQueue = remaining
	end

	local function applyStateToUI(state)
		if not state then
			return
		end

		if statsLabels[1] then
			local dpsValue = typeof(state.dps) == "number" and state.dps or 0
			statsLabels[1].Text = string.format("Data/sec: %s", NumberFormatter.format(dpsValue))
		end

		local cpuLevelSum = 0
		if typeof(state.upgrades) == "table" then
			for upgradeId, level in pairs(state.upgrades) do
				if typeof(level) == "number" and string.sub(upgradeId, 1, 4) == "cpu_" then
					cpuLevelSum += math.max(level, 0)
				end
			end
		end

		if statsLabels[2] then
			statsLabels[2].Text = string.format("CPU Level: %d", cpuLevelSum)
		end

		if statsLabels[3] then
			local prestigeValue = typeof(state.prestige) == "number" and state.prestige or 0
			local coreValue = typeof(state.corePower) == "number" and state.corePower or 0
			statsLabels[3].Text = string.format("Prestige: %d | Core: %s", prestigeValue, NumberFormatter.format(coreValue))
		end
	end

	local function setPrestigeState(canPrestige)
		if prestigeButton then
			prestigeButton.Active = canPrestige
			prestigeButton.Text = canPrestige and "PRESTIGE" or "LOCKED"
		end
		if prestigeOverlay then
			prestigeOverlay.Visible = not canPrestige
		end
	end

	local function applyGlow(card, active)
		if not card then
			return
		end
		local stroke = card:FindFirstChild("AffordStroke")
		if not stroke then
			stroke = Instance.new("UIStroke")
			stroke.Name = "AffordStroke"
			stroke.Thickness = 2
			stroke.Color = Color3.fromRGB(120, 255, 180)
			stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			stroke.Parent = card
		end
		stroke.Transparency = active and 0.25 or 0.7
	end

	local function ensureInteractionScale(button)
		if not button then
			return nil
		end

		local scale = button:FindFirstChild("InteractionScale")
		if not scale then
			scale = Instance.new("UIScale")
			scale.Name = "InteractionScale"
			scale.Scale = 1
			scale.Parent = button
		end

		return scale
	end

	local function playButtonFeedback(button, isMax)
		if not button or not TweenService then
			return
		end

		local scale = ensureInteractionScale(button)
		if not scale then
			return
		end

		local target = isMax and 1.08 or 1.03
		local tweenIn = TweenService:Create(
			scale,
			TweenInfo.new(0.08, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
			{ Scale = target }
		)
		tweenIn:Play()
		tweenIn.Completed:Connect(function()
			TweenService:Create(
				scale,
				TweenInfo.new(0.12, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
				{ Scale = 1 }
			):Play()
		end)
	end

	local function playErrorFeedback(cardData)
		local card = cardData and cardData.card
		if not card or not TweenService then
			return
		end

		local stroke = card:FindFirstChild("ErrorStroke")
		if not stroke then
			stroke = Instance.new("UIStroke")
			stroke.Name = "ErrorStroke"
			stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			stroke.Color = Color3.fromRGB(255, 115, 115)
			stroke.Transparency = 1
			stroke.Parent = card
		end

		local flash = TweenService:Create(
			stroke,
			TweenInfo.new(0.1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
			{ Transparency = 0.2 }
		)
		flash:Play()
		flash.Completed:Connect(function()
			if not stroke.Parent then
				return
			end
			TweenService:Create(
				stroke,
				TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.In),
				{ Transparency = 1 }
			):Play()
		end)
	end

	local function flashMaxBadge(cardData)
		local card = cardData and cardData.card
		if not card or not TweenService then
			return
		end

		local badge = card:FindFirstChild("MaxBadge")
		if not badge then
			badge = Instance.new("TextLabel")
			badge.Name = "MaxBadge"
			badge.AnchorPoint = Vector2.new(1, 0)
			badge.Position = UDim2.new(1, -6, 0, 6)
			badge.Size = UDim2.new(0, 60, 0, 22)
			badge.BackgroundColor3 = Color3.fromRGB(72, 255, 170)
			badge.BackgroundTransparency = 0.1
			badge.TextColor3 = Color3.fromRGB(10, 35, 20)
			badge.Font = Enum.Font.GothamBold
			badge.TextSize = 12
			badge.TextXAlignment = Enum.TextXAlignment.Center
			badge.TextYAlignment = Enum.TextYAlignment.Center
			badge.Text = "MAX"
			badge.ZIndex = card.ZIndex + 1
			badge.Visible = false

			local corner = Instance.new("UICorner")
			corner.CornerRadius = UDim.new(0, 6)
			corner.Parent = badge

			badge.Parent = card
		end

		badge.Visible = true
		badge.TextTransparency = 1

		local fadeIn = TweenService:Create(
			badge,
			TweenInfo.new(0.1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
			{ TextTransparency = 0 }
		)
		fadeIn:Play()

		task.delay(0.6, function()
			if not badge.Parent then
				return
			end
			TweenService:Create(
				badge,
				TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.In),
				{ TextTransparency = 1 }
			):Play()
		end)
	end

	local function enforceMinimumButtonHeight(button)
		if not button or not button:IsA("GuiButton") then
			return
		end

		local size = button.Size
		if size.Y.Scale == 0 and size.Y.Offset < MIN_BUTTON_HEIGHT then
			button.Size = UDim2.new(size.X.Scale, size.X.Offset, size.Y.Scale, MIN_BUTTON_HEIGHT)
		end
	end

	local function refreshCard(upgradeId)
		local cardData = upgradeCards[upgradeId]
		if not cardData then
			return
		end

		local definition = cardData.definition
		local currentLevel = getUpgradeLevel(upgradeId)
		local nextCost = UpgradeConfig.GetCost(upgradeId, currentLevel)
		local hasCost = typeof(nextCost) == "number"
		local canAfford = hasCost and (playerState.data or 0) >= nextCost
		local meetsRequirements = UpgradeConfig.MeetsRequirements(playerState.upgrades, upgradeId)
		local atMax = currentLevel >= definition.maxLevel

		if cardData.title then
			cardData.title.Text = string.format("%s (Lv %d/%d)", definition.name, currentLevel, definition.maxLevel)
		end
		if cardData.description then
			cardData.description.Text = definition.description
		end

		if cardData.costLabel then
			if atMax then
				cardData.costLabel.Text = "Maxed"
			elseif hasCost then
				cardData.costLabel.Text = string.format("Cost: %s", NumberFormatter.format(nextCost))
			else
				cardData.costLabel.Text = "Cost: --"
			end
		end

		local isUnlocked = not atMax and meetsRequirements and hasCost
		cardData.isUnlocked = isUnlocked
		cardData.canAfford = isUnlocked and canAfford

		if cardData.button then
			cardData.button.Text = atMax and "MAX" or "BUY"
			cardData.button.Active = isUnlocked
			cardData.button.AutoButtonColor = isUnlocked and not isTouchOnlyDevice
			if cardData.button:IsA("TextButton") then
				cardData.button.TextTransparency = isUnlocked and 0 or 0.35
			end
		end

		applyGlow(cardData.card, cardData.canAfford == true)
	end

	local function refreshAllCards()
		for upgradeId in pairs(upgradeCards) do
			refreshCard(upgradeId)
		end

		local storageTier = UpgradeConfig.GetStorageTier(playerState.upgrades)
		setPrestigeState(storageTier >= 3)
	end

	local function ensureUiUpdateLoop()
		if uiUpdateStarted then
			return
		end
		uiUpdateStarted = true

		task.spawn(function()
			while task.wait(0.1) do
				if not script.Parent then
					break
				end
				if cachedState then
					applyStateToUI(cachedState)
				end
			end
			uiUpdateStarted = false
		end)
	end

	local function applyState(newState)
		playerState.data = typeof(newState.data) == "number" and newState.data or 0
		playerState.upgrades = typeof(newState.upgrades) == "table" and newState.upgrades or {}
		playerState.prestige = typeof(newState.prestige) == "number" and newState.prestige or 0
		playerState.corePower = typeof(newState.corePower) == "number" and newState.corePower or 0
		if typeof(newState.dps) == "number" then
			playerState.dps = newState.dps
		else
			playerState.dps = 0
		end

		local stateClone = table.clone(newState)
		stateClone.data = playerState.data
		stateClone.upgrades = playerState.upgrades
		stateClone.prestige = playerState.prestige
		stateClone.corePower = playerState.corePower
		stateClone.dps = typeof(newState.dps) == "number" and newState.dps or 0
		cachedState = stateClone

		if displayedData == nil then
			displayedData = playerState.data
		else
			local targetValue = playerState.data or 0
			local snapThreshold = math.max(math.abs(targetValue) * 0.05, 100)
			if math.abs(targetValue - displayedData) > snapThreshold then
				displayedData = targetValue
			end
		end

		refreshAllCards()
		processPendingBuyMaxFeedback()
	end

	local function syncState()
		local payload
		local ok, err = pcall(function()
			payload = requestSync:InvokeServer()
		end)

		if not ok then
			warn("[TerminalClient] RequestSync failed", err)
			return
		end

		if typeof(payload) ~= "table" then
			warn("[TerminalClient] Invalid sync payload")
			return
		end

		applyState(payload)
	end

	local function handleBuy(upgradeId, mode)
		if not buyUpgradeEvent then
			return
		end

		local normalizedMode = mode == BUY_MODE_MAX and BUY_MODE_MAX or BUY_MODE_SINGLE
		local cardData = upgradeCards[upgradeId]
		if not cardData or not cardData.isUnlocked then
			playErrorFeedback(cardData)
			return
		end

		if not cardData.canAfford then
			playErrorFeedback(cardData)
			return
		end

		local payload
		if normalizedMode == BUY_MODE_MAX then
			payload = {
				upgradeId = upgradeId,
				mode = BUY_MODE_MAX,
			}
			queueBuyMaxFeedback(upgradeId)
		else
			payload = upgradeId
		end

		playButtonFeedback(cardData.button, normalizedMode == BUY_MODE_MAX)
		buyUpgradeEvent:FireServer(payload)
		task.defer(syncState)
	end

	local function bindDesktopButton(button, upgradeId)
		if not button or not button:IsA("GuiButton") then
			return
		end

		button.MouseButton1Click:Connect(function()
			handleBuy(upgradeId, BUY_MODE_SINGLE)
		end)

		if UserInputService.MouseEnabled then
			button.MouseButton2Click:Connect(function()
				handleBuy(upgradeId, BUY_MODE_MAX)
			end)
		end
	end

	local function bindTouchButton(button, upgradeId)
		if not button or not button:IsA("GuiButton") then
			return
		end

		local activeTouch
		local touchToken = 0
		local touchConnection
		local longPressTriggered = false

		local function resetTouch()
			if touchConnection then
				touchConnection:Disconnect()
				touchConnection = nil
			end
			activeTouch = nil
		end

		button.InputBegan:Connect(function(input)
			if input.UserInputType ~= Enum.UserInputType.Touch or activeTouch then
				return
			end

			activeTouch = input
			longPressTriggered = false
			touchToken += 1
			local currentToken = touchToken

			if touchConnection then
				touchConnection:Disconnect()
			end
			touchConnection = input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.Cancel then
					resetTouch()
				end
			end)

			task.delay(LONG_PRESS_THRESHOLD, function()
				if activeTouch ~= input or longPressTriggered or touchToken ~= currentToken then
					return
				end

				longPressTriggered = true
				resetTouch()
				handleBuy(upgradeId, BUY_MODE_MAX)
			end)
		end)

		button.InputEnded:Connect(function(input)
			if input ~= activeTouch then
				return
			end

			local pressWasLong = longPressTriggered
			resetTouch()
			if pressWasLong then
				return
			end

			handleBuy(upgradeId, BUY_MODE_SINGLE)
		end)
	end

	local function handlePrestige()
		if not prestigeEvent then
			return
		end
		prestigeEvent:FireServer()
		task.defer(function()
			syncState()
		end)
	end

	local function buildUpgradeCards()
		local function createCard(definition, parentFolder)
			if not parentFolder then
				return
			end
			local card = template:Clone()
			card.Name = definition.id
			card.Parent = parentFolder
			card.Visible = true

			local title = card:FindFirstChild("Title") or card:FindFirstChild("CardTitle")
			local description = card:FindFirstChild("Description") or card:FindFirstChild("CardDesc")
			local costLabel = card:FindFirstChild("CostLabel") or card:FindFirstChild("CardCostLabel")
			local button = card:FindFirstChild("BuyButton") or card:FindFirstChild("CardBuyButton")

			if button then
				enforceMinimumButtonHeight(button)
				button.AutoButtonColor = not isTouchOnlyDevice
				if isTouchOnlyDevice then
					bindTouchButton(button, definition.id)
				else
					bindDesktopButton(button, definition.id)
				end
			end

			upgradeCards[definition.id] = {
				card = card,
				title = title,
				description = description,
				costLabel = costLabel,
				button = button,
				definition = definition,
			}
		end

		for _, definition in ipairs(UpgradeConfig.GetUpgradesByBranch("CPU")) do
			createCard(definition, cpuCards)
		end
		for _, definition in ipairs(UpgradeConfig.GetUpgradesByBranch("RAM")) do
			createCard(definition, ramCards)
		end
		for _, definition in ipairs(UpgradeConfig.GetUpgradesByBranch("STORAGE")) do
			createCard(definition, stoCards)
		end
	end

	local function startSyncLoop()
		if syncLoopStarted then
			return
		end
		syncLoopStarted = true

		task.spawn(function()
			while script.Parent do
				task.wait(0.5)

				if not requestSync then
					if not syncLoopWarningIssued then
						warn("[TerminalClient] RequestSync missing, stopping poll loop")
						syncLoopWarningIssued = true
					end
					break
				end

				local payload
				local ok, result = pcall(function()
					return requestSync:InvokeServer()
				end)

				if not ok then
					local err = result
					if not syncLoopWarningIssued then
						warn("[TerminalClient] RequestSync poll failed:", err)
						syncLoopWarningIssued = true
					end
					break
				else
					payload = result
				end

				if typeof(payload) == "table" then
					applyState(payload)
				end
			end

			syncLoopStarted = false
		end)
	end

	buildUpgradeCards()
	setLoadingStep("Initializing Terminal UI", 0.9)
	ensureUiUpdateLoop()
	syncState()
	startSyncLoop()

	if prestigeButton then
		prestigeButton.MouseButton1Click:Connect(handlePrestige)
	end

	RunService.RenderStepped:Connect(function(dt)
		if not dataValueLabel then
			return
		end

		local frameDt = typeof(dt) == "number" and dt or 0

		local targetData = 0
		if cachedState and typeof(cachedState.data) == "number" then
			targetData = cachedState.data
		elseif typeof(playerState.data) == "number" then
			targetData = playerState.data
		end

		if displayedData == nil then
			displayedData = targetData
		end

		local snapThreshold = math.max(math.abs(targetData) * 0.05, 100)
		if math.abs(targetData - displayedData) > snapThreshold then
			displayedData = targetData
		else
			local alpha = 1 - math.exp(-frameDt * 10)
			displayedData = displayedData + (targetData - displayedData) * alpha
		end

		local predictedDps = 0
		if cachedState and typeof(cachedState.dps) == "number" then
			predictedDps = cachedState.dps
		end

		if predictedDps ~= 0 and frameDt > 0 then
			displayedData += predictedDps * frameDt
		end

		local maxOvershoot = math.max(25, math.abs(targetData) * 0.01, math.abs(predictedDps) * 0.5)
		if displayedData > targetData + maxOvershoot then
			displayedData = targetData + maxOvershoot
		end
		if displayedData < 0 then
			displayedData = 0
		end

		dataValueLabel.Text = formatDataValueText(displayedData)
	end)

	localReady = true
	trySetReady(false)
end)

	if not success then
		warn("[TerminalClient] Initialization failed:", errorMessage)
	end
end

return LoadingInitializer
]]></string>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="32">
          <Properties>
            <string name="Name">StoreHandler</string>
            <string name="Source"></string>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="33">
          <Properties>
            <string name="Name">StoreRuntime</string>
            <string name="Source"><![CDATA[local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")

local ICONS = {
	x2Data = "rbxassetid://72115771900859",
	fasterAuto = "rbxassetid://90107863643546",
	boost5m = "rbxassetid://137979744663076",
	boost1h = "rbxassetid://94963878483638",
}

local TIMEOUT = 5
local OVERLAY_VISIBLE_TRANSPARENCY = 0.45
local OVERLAY_HIDDEN_TRANSPARENCY = 1
local CLOSED_SIZE = UDim2.new(0.62, 0, 0.7, 0)
local OPEN_TWEEN_INFO = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
local CLOSE_TWEEN_INFO = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In)

local function waitForChild(parent, childName)
	if not parent then
		return nil
	end

	return parent:WaitForChild(childName, TIMEOUT)
end

local localPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait()
if not localPlayer then
	return
end

local playerGui = waitForChild(localPlayer, "PlayerGui")
if not playerGui then
	return
end

local terminalUi = waitForChild(playerGui, "TerminalUI")
local root = terminalUi and waitForChild(terminalUi, "Root")
local safeArea = root and waitForChild(root, "SafeArea")
if not safeArea then
	return
end

local storeOverlay = waitForChild(safeArea, "StoreOverlay")
local storeUi = waitForChild(safeArea, "StoreUI")
local topBar = waitForChild(safeArea, "TopBar")
if not (storeOverlay and storeUi and topBar) then
	return
end

local STORE_UI_ZINDEX = math.max(storeUi.ZIndex, 50)
storeUi.ZIndex = STORE_UI_ZINDEX
storeOverlay.ZIndex = math.max(storeOverlay.ZIndex, STORE_UI_ZINDEX - 1)
if storeOverlay:IsA("GuiBase2d") then
	storeOverlay.Active = true
	if storeOverlay:IsA("GuiButton") then
		storeOverlay.AutoButtonColor = false
	end
end

local storeButton = waitForChild(topBar, "StoreButton")
local header = waitForChild(storeUi, "Header")
local closeButton = header and waitForChild(header, "Close")
if not (storeButton and closeButton) then
	return
end

local openPosition = storeUi.Position
local openSize = storeUi.Size
local closedPosition = UDim2.new(openPosition.X.Scale, openPosition.X.Offset, openPosition.Y.Scale + 0.03, openPosition.Y.Offset)

storeOverlay.Visible = false
storeOverlay.BackgroundTransparency = OVERLAY_HIDDEN_TRANSPARENCY
storeUi.Visible = false
storeUi.BackgroundTransparency = 0
storeUi.Size = openSize
storeUi.Position = openPosition

local isStoreOpen = false
local currentOverlayTween = nil
local currentStoreTween = nil

local function cancelTween(tween)
	if tween then
		tween:Cancel()
	end
end

local function applyIconToCard(card, imageId)
	if not (card and imageId) then
		return
	end

	local icon = card:FindFirstChild("Icon")
	if icon and icon:IsA("ImageLabel") then
		icon.Image = imageId
	end
end

local function findCard(name, keyword)
	if not storeUi then
		return nil
	end

	local found = storeUi:FindFirstChild(name, true)
	if found and found:IsA("GuiButton") then
		return found
	end

	if keyword then
		for _, descendant in ipairs(storeUi:GetDescendants()) do
			if descendant:IsA("TextButton") then
				local textValue = descendant.Text or ""
				if string.find(textValue, keyword, 1, true) then
					return descendant
				end
			end
		end
	end

	return nil
end

local cardConfigs = {
	{ name = "x2DataCard", keyword = "x2 Data", icon = ICONS.x2Data },
	{ name = "FasterAutoCard", keyword = "Faster Auto", icon = ICONS.fasterAuto },
	{ name = "+5MinBoostCard", keyword = "+5 Min Boost", icon = ICONS.boost5m },
	{ name = "+1HourBoostCard", keyword = "+1 Hour Boost", icon = ICONS.boost1h },
}

for _, config in ipairs(cardConfigs) do
	local card = findCard(config.name, config.keyword)
	applyIconToCard(card, config.icon)
end

local function openStore()
	if isStoreOpen then
		return
	end

	isStoreOpen = true
	cancelTween(currentOverlayTween)
	cancelTween(currentStoreTween)

	storeOverlay.Visible = true
	storeOverlay.BackgroundTransparency = OVERLAY_HIDDEN_TRANSPARENCY
	storeUi.Visible = true
	storeUi.Size = CLOSED_SIZE
	storeUi.Position = closedPosition
	storeUi.BackgroundTransparency = 1

	local overlayTween = TweenService:Create(storeOverlay, OPEN_TWEEN_INFO, {
		BackgroundTransparency = OVERLAY_VISIBLE_TRANSPARENCY,
	})
	currentOverlayTween = overlayTween
	overlayTween.Completed:Connect(function()
		if currentOverlayTween == overlayTween then
			currentOverlayTween = nil
		end
	end)
	overlayTween:Play()

	local storeTween = TweenService:Create(storeUi, OPEN_TWEEN_INFO, {
		Size = openSize,
		Position = openPosition,
		BackgroundTransparency = 0,
	})
	currentStoreTween = storeTween
	storeTween.Completed:Connect(function()
		if currentStoreTween == storeTween then
			currentStoreTween = nil
		end
	end)
	storeTween:Play()
end

local function closeStore()
	if not storeUi.Visible then
		storeOverlay.Visible = false
		storeOverlay.BackgroundTransparency = OVERLAY_HIDDEN_TRANSPARENCY
		isStoreOpen = false
		return
	end

	isStoreOpen = false
	cancelTween(currentOverlayTween)
	cancelTween(currentStoreTween)

	local overlayTween = TweenService:Create(storeOverlay, CLOSE_TWEEN_INFO, {
		BackgroundTransparency = OVERLAY_HIDDEN_TRANSPARENCY,
	})
	currentOverlayTween = overlayTween
	overlayTween.Completed:Connect(function()
		if currentOverlayTween == overlayTween and not isStoreOpen then
			currentOverlayTween = nil
			storeOverlay.Visible = false
		end
	end)
	overlayTween:Play()

	local storeTween = TweenService:Create(storeUi, CLOSE_TWEEN_INFO, {
		Size = CLOSED_SIZE,
		Position = closedPosition,
		BackgroundTransparency = 1,
	})
	currentStoreTween = storeTween
	storeTween.Completed:Connect(function()
		if currentStoreTween == storeTween and not isStoreOpen then
			currentStoreTween = nil
			storeUi.Visible = false
		end
	end)
	storeTween:Play()
end

local function toggleStore()
	if isStoreOpen then
		closeStore()
	else
		openStore()
	end
end

storeButton.Activated:Connect(toggleStore)
closeButton.Activated:Connect(closeStore)

storeOverlay.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		closeStore()
	end
end)
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="34">
          <Properties>
            <string name="Name">StoreUIController</string>
            <string name="Source"><![CDATA[local StoreUIController = {}
local initialized = false
local moduleApi

function StoreUIController.Init(context)
	if initialized then
		return moduleApi
	end

	local ui = context.ui or {}
	local safeArea = ui.safeArea
	local topBar = ui.topBar
	local main = ui.main
	local toastArea = ui.toastArea
	local TweenService = context.TweenService
	local waitForChildWithTimeout = context.waitForChildWithTimeout
	local storeAnalyticsEvent = context.remotes and context.remotes.storeAnalyticsEvent
	local MarketplaceService = context.MarketplaceService
	local UserInputService = context.UserInputService
	local player = context.player

	if not (safeArea and topBar and player and TweenService and waitForChildWithTimeout and MarketplaceService and UserInputService) then
		return nil
	end

	local storeOverlay = waitForChildWithTimeout(safeArea, "StoreOverlay")
	local storeUi = waitForChildWithTimeout(safeArea, "StoreUI")
	local storeButton = waitForChildWithTimeout(topBar, "StoreButton")
	local storeHeader = storeUi and waitForChildWithTimeout(storeUi, "Header")
	local storeCloseButton = storeHeader and waitForChildWithTimeout(storeHeader, "Close")
	local storeBody = storeUi and waitForChildWithTimeout(storeUi, "Body")
	local gamepassesSection = storeBody and waitForChildWithTimeout(storeBody, "Gamepasses")
	local devProductsSection = storeBody and waitForChildWithTimeout(storeBody, "DevProducts")
	local gamepassList = gamepassesSection and waitForChildWithTimeout(gamepassesSection, "List")
	local devProductList = devProductsSection and waitForChildWithTimeout(devProductsSection, "List")
	local storeCards = {}

	if toastArea and toastArea:IsA("GuiObject") then
		if storeUi and storeUi:IsA("GuiObject") and storeUi.ZIndex <= toastArea.ZIndex then
			storeUi.ZIndex = toastArea.ZIndex + 5
		end

		if main and main:IsA("GuiObject") and main.ZIndex >= toastArea.ZIndex then
			main.ZIndex = math.max(0, toastArea.ZIndex - 5)
		end
	end

	local function determinePlatform()
		if UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled then
			return "Mobile"
		end
		return "Desktop"
	end

	local analyticsPlatform = determinePlatform()
	local storeStateReported = nil

	local function sendStoreAnalytics(eventName, extra)
		if not storeAnalyticsEvent or typeof(eventName) ~= "string" then
			return
		end

		local payload = table.clone(extra or {})
		payload.Event = eventName
		payload.Platform = analyticsPlatform
		storeAnalyticsEvent:FireServer(payload)
	end

	local function trackStoreState(isOpen)
		if storeStateReported == isOpen then
			return
		end
		storeStateReported = isOpen

		local basePayload = {
			ItemName = "",
			ProductType = "",
			ProductId = 0,
		}

		if isOpen then
			sendStoreAnalytics("StoreOpened", basePayload)
		else
			sendStoreAnalytics("StoreClosed", basePayload)
		end
	end

	if not (storeOverlay and storeUi and storeButton and storeCloseButton) then
		return nil
	end

	local overlayVisibleTransparency = 0.45
	local overlayHiddenTransparency = 1
	local storeOpenSize = UDim2.fromScale(0.7, 0.78)
	local storeClosedSize = UDim2.fromScale(0.62, 0.7)
	local storeOpenPosition = storeUi.Position
	local storeClosedPosition = UDim2.new(storeOpenPosition.X.Scale, storeOpenPosition.X.Offset, storeOpenPosition.Y.Scale + 0.03, storeOpenPosition.Y.Offset)
	local openTweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local closeTweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In)

	storeOverlay.Visible = false
	storeOverlay.BackgroundTransparency = overlayHiddenTransparency
	storeUi.Visible = false
	storeUi.Size = storeOpenSize
	storeUi.Position = storeOpenPosition
	storeUi.BackgroundTransparency = 0

	local isStoreOpen = false
	local currentOverlayTween = nil
	local currentStoreTween = nil

	local function cancelTween(tween)
		if tween then
			tween:Cancel()
		end
	end

	local BEST_VALUE_KEYWORD = "+1 Hour Boost"

	local function createBestValueRibbon(button)
		if not button or not button:IsA("GuiObject") then
			return nil
		end

		local existing = button:FindFirstChild("BestValueRibbon")
		if existing then
			return existing
		end

		local ribbon = Instance.new("TextLabel")
		ribbon.Name = "BestValueRibbon"
		ribbon.Text = "BEST VALUE"
		ribbon.Font = Enum.Font.GothamBold
		ribbon.TextSize = 14
		ribbon.TextWrapped = true
		ribbon.TextColor3 = Color3.new(0, 0, 0)
		ribbon.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
		ribbon.BorderSizePixel = 0
		ribbon.Size = UDim2.new(0, 100, 0, 24)
		ribbon.Position = UDim2.new(0, 8, 0, 8)
		ribbon.Rotation = -15
		ribbon.Active = false
		ribbon.Selectable = false
		ribbon.ZIndex = button.ZIndex + 5

		local padding = Instance.new("UIPadding")
		padding.PaddingTop = UDim.new(0, 2)
		padding.PaddingBottom = UDim.new(0, 2)
		padding.PaddingLeft = UDim.new(0, 4)
		padding.PaddingRight = UDim.new(0, 4)
		padding.Parent = ribbon

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 6)
		corner.Parent = ribbon

		ribbon.Parent = button
		return ribbon
	end

	local function updateBestValueRibbon(cardInfo)
		if not cardInfo.isBestValue then
			return
		end

		local ribbon = cardInfo.bestValueRibbon
		if not ribbon then
			ribbon = createBestValueRibbon(cardInfo.button)
			cardInfo.bestValueRibbon = ribbon
		end

		if ribbon then
			ribbon.Visible = not cardInfo.owned
		end
	end

	local function setOwnedState(cardInfo, owned)
		if not cardInfo.button then
			return
		end

		cardInfo.owned = owned
		if owned then
			cardInfo.button.Text = "Owned"
			cardInfo.button.Active = false
			cardInfo.button.AutoButtonColor = false
			if cardInfo.dimColor then
				cardInfo.button.BackgroundColor3 = cardInfo.dimColor
			end
		else
			cardInfo.button.Text = cardInfo.defaultText
			cardInfo.button.Active = cardInfo.defaultActive
			cardInfo.button.AutoButtonColor = cardInfo.defaultAutoButtonColor
			cardInfo.button.BackgroundColor3 = cardInfo.defaultColor
		end

		updateBestValueRibbon(cardInfo)
	end

	local function buildItemPayload(cardInfo)
		return {
			ItemName = tostring(cardInfo.button and cardInfo.button.Text or ""),
			ProductType = tostring(cardInfo.productType or ""),
			ProductId = typeof(cardInfo.productId) == "number" and cardInfo.productId or 0,
		}
	end

	local function registerCard(button)
		if not button or not button:IsA("TextButton") then
			return
		end

		local productType = button:GetAttribute("ProductType")
		local productIdAttribute = button:GetAttribute("ProductId")
		local productId = nil

		if typeof(productIdAttribute) == "number" then
			productId = productIdAttribute
		elseif typeof(productIdAttribute) == "string" then
			productId = tonumber(productIdAttribute)
		end

		local cardInfo = {
			button = button,
			productType = typeof(productType) == "string" and productType or nil,
			productId = productId,
			defaultText = button.Text,
			defaultColor = button.BackgroundColor3,
			defaultAutoButtonColor = button.AutoButtonColor,
			defaultActive = button.Active,
			dimColor = Color3.new(
				math.clamp(button.BackgroundColor3.R * 0.6, 0, 1),
				math.clamp(button.BackgroundColor3.G * 0.6, 0, 1),
				math.clamp(button.BackgroundColor3.B * 0.6, 0, 1)
			),
		}

		local buttonText = button.Text or ""
		cardInfo.isBestValue = string.find(buttonText, BEST_VALUE_KEYWORD, 1, true) ~= nil
		if cardInfo.isBestValue then
			cardInfo.bestValueRibbon = createBestValueRibbon(button)
			updateBestValueRibbon(cardInfo)
		end

		button.Activated:Connect(function()
			sendStoreAnalytics("ItemClicked", buildItemPayload(cardInfo))

			local productTypeLower = typeof(cardInfo.productType) == "string" and string.lower(cardInfo.productType) or ""
			if productTypeLower == "gamepass" and cardInfo.owned then
				return
			end

			if typeof(cardInfo.productId) ~= "number" then
				return
			end

			sendStoreAnalytics("PurchasePromptShown", buildItemPayload(cardInfo))

			if productTypeLower == "gamepass" then
				MarketplaceService:PromptGamePassPurchase(player, cardInfo.productId)
			elseif productTypeLower == "devproduct" then
				MarketplaceService:PromptProductPurchase(player, cardInfo.productId)
			end
		end)

		table.insert(storeCards, cardInfo)
	end

	local function registerCardsUnder(parent)
		if not parent then
			return
		end

		for _, descendant in ipairs(parent:GetDescendants()) do
			if descendant:IsA("TextButton") then
				registerCard(descendant)
			end
		end
	end

	registerCardsUnder(gamepassList)
	registerCardsUnder(devProductList)

	local function refreshGamepassOwnership()
		for _, cardInfo in ipairs(storeCards) do
			local productTypeLower = typeof(cardInfo.productType) == "string" and string.lower(cardInfo.productType) or ""
			if productTypeLower == "gamepass" and typeof(cardInfo.productId) == "number" then
				task.spawn(function(info)
					local ok, owned = pcall(function()
						return MarketplaceService:UserOwnsGamePassAsync(player.UserId, info.productId)
					end)

					if ok then
						setOwnedState(info, owned == true)
					end
				end, cardInfo)
			end
		end
	end

	local function openStore()
		if isStoreOpen then
			return
		end

		isStoreOpen = true
		cancelTween(currentOverlayTween)
		currentOverlayTween = nil
		cancelTween(currentStoreTween)
		currentStoreTween = nil

		storeOverlay.Visible = true
		storeOverlay.BackgroundTransparency = overlayHiddenTransparency
		storeUi.Visible = true
		storeUi.Size = storeClosedSize
		storeUi.Position = storeClosedPosition
		storeUi.BackgroundTransparency = 1

		local overlayTween = TweenService:Create(storeOverlay, openTweenInfo, {
			BackgroundTransparency = overlayVisibleTransparency,
		})
		currentOverlayTween = overlayTween
		overlayTween.Completed:Connect(function()
			if currentOverlayTween == overlayTween then
				currentOverlayTween = nil
			end
		end)
		overlayTween:Play()

		local uiTween = TweenService:Create(storeUi, openTweenInfo, {
			Size = storeOpenSize,
			Position = storeOpenPosition,
			BackgroundTransparency = 0,
		})
		currentStoreTween = uiTween
		uiTween.Completed:Connect(function()
			if currentStoreTween == uiTween then
				currentStoreTween = nil
			end
		end)
		uiTween:Play()

		refreshGamepassOwnership()
		trackStoreState(true)
	end

	local function closeStore()
		if not storeUi.Visible then
			storeOverlay.Visible = false
			storeOverlay.BackgroundTransparency = overlayHiddenTransparency
			isStoreOpen = false
			trackStoreState(false)
			storeUi.Size = storeOpenSize
			storeUi.Position = storeOpenPosition
			storeUi.BackgroundTransparency = 0
			return
		end

		isStoreOpen = false
		trackStoreState(false)
		cancelTween(currentOverlayTween)
		currentOverlayTween = nil
		cancelTween(currentStoreTween)
		currentStoreTween = nil

		local overlayTween = TweenService:Create(storeOverlay, closeTweenInfo, {
			BackgroundTransparency = overlayHiddenTransparency,
		})
		currentOverlayTween = overlayTween
		overlayTween.Completed:Connect(function()
			if currentOverlayTween == overlayTween then
				currentOverlayTween = nil
			end
			if not isStoreOpen then
				storeOverlay.Visible = false
			end
		end)
		overlayTween:Play()

		local uiTween = TweenService:Create(storeUi, closeTweenInfo, {
			Size = storeClosedSize,
			Position = storeClosedPosition,
			BackgroundTransparency = 1,
		})
		currentStoreTween = uiTween
		uiTween.Completed:Connect(function()
			if currentStoreTween == uiTween then
				currentStoreTween = nil
			end
			if not isStoreOpen then
				storeUi.Visible = false
				storeUi.Size = storeOpenSize
				storeUi.Position = storeOpenPosition
				storeUi.BackgroundTransparency = 0
			end
		end)
		uiTween:Play()
	end

	local function toggleStore()
		if isStoreOpen then
			closeStore()
		else
			openStore()
		end
	end

	if storeButton and storeButton:IsA("GuiButton") then
		storeButton.Activated:Connect(toggleStore)
	end

	if storeCloseButton and storeCloseButton:IsA("GuiButton") then
		storeCloseButton.Activated:Connect(closeStore)
	end

	if storeOverlay and storeOverlay:IsA("GuiButton") then
		storeOverlay.Activated:Connect(closeStore)
	end

	if storeOverlay and storeOverlay:IsA("GuiObject") then
		storeOverlay.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				closeStore()
			end
		end)
	end

	moduleApi = {
		RefreshGamepassOwnership = refreshGamepassOwnership,
	}
	initialized = true

	return moduleApi
end

return StoreUIController
]]></string>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="35">
          <Properties>
            <string name="Name">TerminalClient</string>
            <string name="Source"><![CDATA[local LoadingInitializer = require(script.Parent:WaitForChild("LoadingInitializer"))
LoadingInitializer.Init()
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="36">
          <Properties>
            <string name="Name">TerminalUIBinder</string>
            <string name="Source"><![CDATA[local TerminalUIBinder = {}
local initialized = false

function TerminalUIBinder.Init(context)
	if initialized then
		return context.ui ~= nil
	end

	local playerGui = context.playerGui
	if not playerGui then
		warn("[TerminalClient] PlayerGui missing")
		return false
	end

	local screenGui = playerGui:WaitForChild("TerminalUI", 5)
	if not screenGui then
		warn("[TerminalClient] TerminalUI failed to load")
		return false
	end

	local safeFind = context.safeFind

	local root = safeFind(screenGui, "Root")
	local safeArea = root and safeFind(root, "SafeArea")
	local topBar = safeArea and safeFind(safeArea, "TopBar")
	local main = safeArea and safeFind(safeArea, "Main")
	local columns = main and safeFind(main, "Columns")
	local cpuColumn = columns and safeFind(columns, "CPUColumn")
	local ramColumn = columns and safeFind(columns, "RAMColumn")
	local stoColumn = columns and safeFind(columns, "STOColumn")
	local cpuCards = cpuColumn and safeFind(cpuColumn, "Cards_CPU")
	local ramCards = ramColumn and safeFind(ramColumn, "Cards_RAM")
	local stoCards = stoColumn and safeFind(stoColumn, "Cards_STORAGE")
	local rightPanel = main and safeFind(main, "RightPanel")
	local statsBox = rightPanel and safeFind(rightPanel, "StatsBox")
	local prestigeBox = rightPanel and safeFind(rightPanel, "PrestigeBox")
	local toastArea = safeArea and safeFind(safeArea, "ToastArea")

	if not (root and safeArea and topBar and main and columns and cpuCards and ramCards and stoCards and statsBox and prestigeBox and toastArea) then
		warn("[TerminalClient] UI hierarchy incomplete")
		return false
	end

	context.ui = {
		screenGui = screenGui,
		root = root,
		safeArea = safeArea,
		topBar = topBar,
		main = main,
		columns = columns,
		cpuColumn = cpuColumn,
		ramColumn = ramColumn,
		stoColumn = stoColumn,
		cpuCards = cpuCards,
		ramCards = ramCards,
		stoCards = stoCards,
		rightPanel = rightPanel,
		statsBox = statsBox,
		prestigeBox = prestigeBox,
		toastArea = toastArea,
	}

	initialized = true
	return true
end

return TerminalUIBinder
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="37">
          <Properties>
            <string name="Name">ToastController</string>
            <string name="Source"><![CDATA[local ToastController = {}
local initialized = false
local moduleApi

function ToastController.Init(context)
	if initialized then
		return moduleApi
	end

	local ui = context.ui or {}
	local toastArea = ui.toastArea
	local safeArea = ui.safeArea
	local root = ui.root
	local TweenService = context.TweenService
	local NumberFormatter = context.NumberFormatter
	local offlinePreviewEvent = context.remotes and context.remotes.offlinePreviewEvent

	if not (toastArea and safeArea and root and TweenService and NumberFormatter) then
		return nil
	end

	local clientReady = context.IsClientReady and context.IsClientReady() == true
	local onClientReady = context.OnClientReady

	local pendingOfflinePreviewPayloads = {}
	local offlineUiReady = false
	local processOfflinePreviewPayload
	local pendingClientReadyPayload = nil

	local function queueOfflinePreview(payload)
		table.insert(pendingOfflinePreviewPayloads, payload)
	end

	local function flushOfflinePreviewQueue()
		if not offlineUiReady or not clientReady or #pendingOfflinePreviewPayloads == 0 then
			return
		end

		local queued = table.clone(pendingOfflinePreviewPayloads)
		table.clear(pendingOfflinePreviewPayloads)

		for _, payload in ipairs(queued) do
			processOfflinePreviewPayload(payload)
		end
	end

	local toastLayout = toastArea and toastArea:FindFirstChildWhichIsA("UIListLayout")
	if toastLayout then
		toastLayout.SortOrder = Enum.SortOrder.LayoutOrder
		toastLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	end

	if toastArea and toastArea:IsA("GuiObject") then
		toastArea.Visible = true
		toastArea.ZIndex = math.max(toastArea.ZIndex, 40)
		toastArea.Active = false
	end

	local offlineToastTemplate
	local offlineToastTargetSize
	local offlineToastSequence = 0
	local activeOfflineToasts = {}
	local MAX_OFFLINE_TOASTS = 3
	local OFFLINE_TOAST_LIFETIME = 4.5

	local function findDescriptionLabel(toast)
		if not toast then
			return nil
		end

		local description = toast:FindFirstChild("Description")
		if description and description:IsA("TextLabel") then
			return description
		end

		for _, descendant in ipairs(toast:GetDescendants()) do
			if descendant:IsA("TextLabel") then
				return descendant
			end
		end

		return nil
	end

	local function ensureBoostBadge(frame)
		if not frame then
			return nil
		end

		local badge = frame:FindFirstChild("BoostBadge")
		if badge and badge:IsA("TextLabel") then
			return badge
		end

		badge = Instance.new("TextLabel")
		badge.Name = "BoostBadge"
		badge.AnchorPoint = Vector2.new(1, 0)
		badge.Position = UDim2.new(1, -8, 0, 8)
		badge.Size = UDim2.new(0, 130, 0, 24)
		badge.BackgroundColor3 = Color3.fromRGB(255, 214, 102)
		badge.BackgroundTransparency = 0.05
		badge.TextColor3 = Color3.fromRGB(40, 30, 10)
		badge.Font = Enum.Font.GothamBold
		badge.TextSize = 12
		badge.Text = "BOOST APPLIED"
		badge.TextXAlignment = Enum.TextXAlignment.Center
		badge.TextYAlignment = Enum.TextYAlignment.Center
		badge.Visible = false
		if frame:IsA("GuiObject") then
			badge.ZIndex = frame.ZIndex + 1
		else
			badge.ZIndex = 2
		end
		badge.Parent = frame

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 8)
		corner.Parent = badge

		local stroke = Instance.new("UIStroke")
		stroke.Thickness = 1
		stroke.Color = Color3.fromRGB(255, 255, 255)
		stroke.Transparency = 0.2
		stroke.Parent = badge

		return badge
	end

	local function resolveOfflineToastTemplate()
		if offlineToastTemplate and offlineToastTemplate.Parent then
			return offlineToastTemplate
		end

		local containers = { toastArea, safeArea, root }
		for _, container in ipairs(containers) do
			if container then
				local candidate = container:FindFirstChild("OfflineToast", true)
				if candidate then
					offlineToastTemplate = candidate
					if offlineToastTemplate:IsA("GuiObject") then
						offlineToastTargetSize = offlineToastTemplate.Size
						offlineToastTemplate.Visible = false
					end
					ensureBoostBadge(offlineToastTemplate)
					return offlineToastTemplate
				end
			end
		end

		return nil
	end

	local function playToastIntro(toast, descriptionLabel)
		if not toast then
			return
		end

		local finalSize = offlineToastTargetSize
		if toast:IsA("GuiObject") then
			if not finalSize then
				finalSize = toast.Size
				offlineToastTargetSize = finalSize
			end
			toast.Size = UDim2.new(finalSize.X.Scale, finalSize.X.Offset, 0, 0)
			TweenService:Create(
				toast,
				TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
				{ Size = finalSize }
			):Play()
		end

		if descriptionLabel then
			descriptionLabel.TextTransparency = 1
			TweenService:Create(
				descriptionLabel,
				TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
				{ TextTransparency = 0 }
			):Play()
		end
	end

	local function removeToastInstance(toast, immediate)
		if not toast or toast:GetAttribute("OfflineToastRemoving") then
			return
		end

		toast:SetAttribute("OfflineToastRemoving", true)

		for i = #activeOfflineToasts, 1, -1 do
			if activeOfflineToasts[i] == toast then
				table.remove(activeOfflineToasts, i)
				break
			end
		end

		local function destroyToast()
			if toast then
				toast:Destroy()
			end
		end

		if immediate or not toast:IsA("GuiObject") then
			destroyToast()
			return
		end

		local targetSize = offlineToastTargetSize or toast.Size
		local collapseSize = UDim2.new(targetSize.X.Scale, targetSize.X.Offset, 0, 0)

		local shrinkTween = TweenService:Create(
			toast,
			TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
			{ Size = collapseSize }
		)
		shrinkTween.Completed:Connect(destroyToast)
		shrinkTween:Play()

		local descriptionLabel = findDescriptionLabel(toast)
		if descriptionLabel then
			TweenService:Create(
				descriptionLabel,
				TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
				{ TextTransparency = 1 }
			):Play()
		end

		local badge = toast:FindFirstChild("BoostBadge")
		if badge and badge:IsA("GuiObject") then
			TweenService:Create(
				badge,
				TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
				{
					TextTransparency = 1,
					BackgroundTransparency = 1,
				}
			):Play()
		end
	end

	local function enforceToastLimit()
		while #activeOfflineToasts > MAX_OFFLINE_TOASTS do
			local oldest = activeOfflineToasts[#activeOfflineToasts]
			removeToastInstance(oldest, true)
		end
	end

	local function spawnOfflineToast()
		if not toastArea then
			return nil, nil
		end

		local template = resolveOfflineToastTemplate()
		if not template then
			return nil, nil
		end

		local toast = template:Clone()
		toast.Name = "OfflineToast"
		toast.Visible = true
		toast.Active = false
		if toastArea:IsA("GuiObject") then
			toast.ZIndex = math.max(toast.ZIndex, toastArea.ZIndex + 1)
			toastArea.Visible = true
		end
		offlineToastSequence += 1
		toast.LayoutOrder = -offlineToastSequence
		toast.Parent = toastArea

		local descriptionLabel = findDescriptionLabel(toast)
		return toast, descriptionLabel
	end

	processOfflinePreviewPayload = function(payload)
		if typeof(payload) ~= "table" then
			return
		end

		local totalAmount = tonumber(payload.totalAmount or payload.amount or payload.Amount)
		if not totalAmount or totalAmount <= 0 then
			return
		end

		local toastFrame, descriptionLabel = spawnOfflineToast()
		if not toastFrame or not descriptionLabel then
			return
		end

		local baseAmount = tonumber(payload.baseAmount) or 0
		local boostedAmount = tonumber(payload.boostedAmount) or math.max(0, totalAmount - baseAmount)
		local prestigeMultiplier = tonumber(payload.prestigeMultiplier)

		local lines = {}
		table.insert(lines, string.format("+%s Data while away", NumberFormatter.format(totalAmount)))
		if boostedAmount > 0 then
			table.insert(
				lines,
				string.format(
					"Base: +%s   Boosted: +%s",
					NumberFormatter.format(math.max(baseAmount, 0)),
					NumberFormatter.format(boostedAmount)
				)
			)
		end
		if prestigeMultiplier and prestigeMultiplier > 1 then
			table.insert(lines, string.format("Prestige Bonus: x%.2f", prestigeMultiplier))
		end
		descriptionLabel.Text = table.concat(lines, "\n")

		local hadBoostsValue = payload.hadBoosts
		if typeof(hadBoostsValue) ~= "boolean" then
			hadBoostsValue = payload.HadBoosts == true
		end
		local boostApplied = hadBoostsValue == true
		toastFrame:SetAttribute("HadOfflineBoosts", boostApplied)

		local badge = ensureBoostBadge(toastFrame)
		if badge then
			badge.Visible = boostApplied
			if not boostApplied then
				badge.TextTransparency = 0
				badge.BackgroundTransparency = 0.05
			end
		end

		playToastIntro(toastFrame, descriptionLabel)

		table.insert(activeOfflineToasts, 1, toastFrame)
		enforceToastLimit()

		task.delay(OFFLINE_TOAST_LIFETIME, function()
			removeToastInstance(toastFrame)
		end)
	end

	local function handleOfflinePreview(payload)
		if not clientReady then
			pendingClientReadyPayload = payload
			return
		end

		if not offlineUiReady then
			queueOfflinePreview(payload)
			return
		end

		processOfflinePreviewPayload(payload)
	end

	if toastArea and toastArea:IsA("GuiObject") then
		task.spawn(function()
			while true do
				local template = resolveOfflineToastTemplate()
				if template then
					offlineUiReady = true
					flushOfflinePreviewQueue()
					return
				end

				task.wait(0.1)
			end
		end)
	end

	if offlinePreviewEvent then
		offlinePreviewEvent.OnClientEvent:Connect(handleOfflinePreview)
	end

	if onClientReady then
		onClientReady(function()
			clientReady = true

			if pendingClientReadyPayload then
				local payload = pendingClientReadyPayload
				pendingClientReadyPayload = nil
				handleOfflinePreview(payload)
			end

			flushOfflinePreviewQueue()
		end)
	else
		clientReady = true
	end

	if clientReady then
		if pendingClientReadyPayload then
			local payload = pendingClientReadyPayload
			pendingClientReadyPayload = nil
			handleOfflinePreview(payload)
		end
		flushOfflinePreviewQueue()
	end

	local toastCooldown = false

	local function showToast(message)
		if not toastArea then
			return
		end

		if toastCooldown then
			return
		end

		local toast = Instance.new("TextLabel")
		toast.Name = "Toast"
		toast.BackgroundTransparency = 1
		toast.TextColor3 = Color3.new(1, 1, 1)
		toast.TextStrokeTransparency = 0.5
		toast.Font = Enum.Font.GothamBold
		toast.TextSize = 20
		toast.Text = message
		toast.AnchorPoint = Vector2.new(0.5, 0)
		toast.Position = UDim2.new(0.5, 0, 0, 0)
		toast.Parent = toastArea

		toast.TextTransparency = 1
		toast.Visible = true
		toastCooldown = true

		local fadeIn = TweenService:Create(toast, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { TextTransparency = 0 })
		local fadeOut = TweenService:Create(toast, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In), { TextTransparency = 1 })

		fadeIn.Completed:Connect(function()
			task.delay(1.2, function()
				fadeOut:Play()
			end)
		end)

		fadeOut.Completed:Connect(function()
			toastCooldown = false
			toast:Destroy()
		end)

		fadeIn:Play()
	end

	moduleApi = {
		ShowToast = showToast,
	}
	initialized = true

	return moduleApi
end

return ToastController
]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="Workspace" referent="38">
    <Properties>
      <string name="Name">Workspace</string>
      <bool name="FilteringEnabled">true</bool>
      <bool name="NeedsPivotMigration">false</bool>
    </Properties>
    <Item class="Part" referent="39">
      <Properties>
        <string name="Name">Baseplate</string>
        <bool name="Anchored">true</bool>
        <Color3uint8 name="Color3uint8">6512483</Color3uint8>
        <bool name="Locked">true</bool>
        <Vector3 name="Position">
          <X>0</X>
          <Y>-10</Y>
          <Z>0</Z>
        </Vector3>
        <Vector3 name="size">
          <X>512</X>
          <Y>20</Y>
          <Z>512</Z>
        </Vector3>
      </Properties>
    </Item>
  </Item>
</roblox>